#include <drx3D/SharedMemory/PhysicsClientSharedMemory.h>
#include <drx3D/SharedMemory/PosixSharedMemory.h>
#include <drx3D/SharedMemory/Win32SharedMemory.h>
#include <drx3D/Common/b3AlignedObjectArray.h>
#include <drx3D/Common/b3Vec3.h>
#include <string.h>
#include <drx3D/Common/b3HashMap.h>
#include <drx3D/Common/b3Logging.h>
#include <drx3D/Common/ResourcePath.h>
#include <drx3D/Importers/BulletFile.h>
//#include <drx3D/Importers/autogenerated/bullet.h>
#include <drx3D/SharedMemory/SharedMemoryBlock.h>
#include <drx3D/SharedMemory/BodyJointInfoUtility.h>
#include <drx3D/SharedMemory/SharedMemoryUserData.h>
#include <drx3D/Maths/Linear/Quickprof.h>
#include <drx3D/Physics/Dynamics/ConstraintSolver/Generic6DofSpring2Constraint.h>

struct BodyJointInfoCache
{
	STxt m_baseName;
	b3AlignedObjectArray<b3JointInfo> m_jointInfo;
	STxt m_bodyName;
	AlignedObjectArray<i32> m_userDataIds;
	i32 m_numDofs;
	~BodyJointInfoCache()
	{
	}
};

struct PhysicsClientSharedMemoryInternalData
{
	SharedMemoryInterface* m_sharedMemory;
	bool m_ownsSharedMemory;
	SharedMemoryBlock* m_testBlock1;

	AlignedObjectArray<CProfileSample*> m_profileTimings;
	HashMap<HashString, STxt*> m_profileTimingStringArray;

	HashMap<HashInt, BodyJointInfoCache*> m_bodyJointMap;
	HashMap<HashInt, b3UserConstraint> m_userConstraintInfoMap;

	AlignedObjectArray<TmpFloat3> m_debugLinesFrom;
	AlignedObjectArray<TmpFloat3> m_debugLinesTo;
	AlignedObjectArray<TmpFloat3> m_debugLinesColor;

	i32 m_cachedCameraPixelsWidth;
	i32 m_cachedCameraPixelsHeight;
	AlignedObjectArray<u8> m_cachedCameraPixelsRGBA;
	AlignedObjectArray<float> m_cachedCameraDepthBuffer;
	AlignedObjectArray<i32> m_cachedSegmentationMaskBuffer;

	AlignedObjectArray<b3ContactPointData> m_cachedContactPoints;
	AlignedObjectArray<b3OverlappingObject> m_cachedOverlappingObjects;
	AlignedObjectArray<b3VisualShapeData> m_cachedVisualShapes;
	AlignedObjectArray<b3CollisionShapeData> m_cachedCollisionShapes;

	b3MeshData m_cachedMeshData;
	AlignedObjectArray<b3MeshVertex> m_cachedVertexPositions;

	AlignedObjectArray<b3VRControllerEvent> m_cachedVREvents;
	AlignedObjectArray<b3KeyboardEvent> m_cachedKeyboardEvents;
	AlignedObjectArray<b3MouseEvent> m_cachedMouseEvents;
	AlignedObjectArray<double> m_cachedMassMatrix;
	AlignedObjectArray<b3RayHitInfo> m_raycastHits;

	AlignedObjectArray<i32> m_bodyIdsRequestInfo;
	AlignedObjectArray<i32> m_constraintIdsRequestInfo;

	AlignedObjectArray<i32> m_userDataIdsRequestInfo;
	HashMap<HashInt, SharedMemoryUserData> m_userDataMap;
	HashMap<SharedMemoryUserDataHashKey, i32> m_userDataHandleLookup;

	AlignedObjectArray<char> m_cachedReturnData;
	b3UserDataValue m_cachedReturnDataValue;

	SharedMemoryStatus m_tempBackupServerStatus;

	SharedMemoryStatus m_lastServerStatus;

	SendActualStateSharedMemoryStorage m_cachedState;
	
	i32 m_counter;

	bool m_isConnected;
	bool m_waitingForServer;
	bool m_hasLastServerStatus;
	i32 m_sharedMemoryKey;
	bool m_verboseOutput;
	double m_timeOutInSeconds;

	

	PhysicsClientSharedMemoryInternalData()
		: m_sharedMemory(0),
		  m_ownsSharedMemory(false),
		  m_testBlock1(0),
		  m_cachedCameraPixelsWidth(0),
		  m_cachedCameraPixelsHeight(0),
		  m_counter(0),
		  m_isConnected(false),
		  m_waitingForServer(false),
		  m_hasLastServerStatus(false),
		  m_sharedMemoryKey(SHARED_MEMORY_KEY),
		  m_verboseOutput(false),
		  m_timeOutInSeconds(1e30)
	{
		m_cachedMeshData.m_numVertices = 0;
		m_cachedMeshData.m_vertices = 0;
	}

	void processServerStatus();

	bool canSubmitCommand() const;
};

i32 PhysicsClientSharedMemory::getNumBodies() const
{
	return m_data->m_bodyJointMap.size();
}

i32 PhysicsClientSharedMemory::getBodyUniqueId(i32 serialIndex) const
{
	if ((serialIndex >= 0) && (serialIndex < getNumBodies()))
	{
		return m_data->m_bodyJointMap.getKeyAtIndex(serialIndex).getUid1();
	}
	return -1;
}

bool PhysicsClientSharedMemory::getBodyInfo(i32 bodyUniqueId, struct b3BodyInfo& info) const
{
	BodyJointInfoCache** bodyJointsPtr = m_data->m_bodyJointMap[bodyUniqueId];
	if (bodyJointsPtr && *bodyJointsPtr)
	{
		BodyJointInfoCache* bodyJoints = *bodyJointsPtr;
		strcpy(info.m_baseName, bodyJoints->m_baseName.c_str());
		strcpy(info.m_bodyName, bodyJoints->m_bodyName.c_str());
		return true;
	}

	return false;
}

i32 PhysicsClientSharedMemory::getNumJoints(i32 bodyUniqueId) const
{
	BodyJointInfoCache** bodyJointsPtr = m_data->m_bodyJointMap[bodyUniqueId];
	if (bodyJointsPtr && *bodyJointsPtr)
	{
		BodyJointInfoCache* bodyJoints = *bodyJointsPtr;

		return bodyJoints->m_jointInfo.size();
	}
	return 0;
}

i32 PhysicsClientSharedMemory::getNumDofs(i32 bodyUniqueId) const
{
        BodyJointInfoCache** bodyJointsPtr = m_data->m_bodyJointMap[bodyUniqueId];
        if (bodyJointsPtr && *bodyJointsPtr)
        {
                BodyJointInfoCache* bodyJoints = *bodyJointsPtr;
                return bodyJoints->m_numDofs;
        }
        return 0;
}

bool PhysicsClientSharedMemory::getJointInfo(i32 bodyUniqueId, i32 jointIndex, b3JointInfo& info) const
{
	BodyJointInfoCache** bodyJointsPtr = m_data->m_bodyJointMap[bodyUniqueId];
	if (bodyJointsPtr && *bodyJointsPtr)
	{
		BodyJointInfoCache* bodyJoints = *bodyJointsPtr;
		if ((jointIndex >= 0) && (jointIndex < bodyJoints->m_jointInfo.size()))
		{
			info = bodyJoints->m_jointInfo[jointIndex];
			info.m_qSize = 0;
			info.m_uSize = 0;
			switch (info.m_jointType)
			{
				case eSphericalType:
				{
					info.m_qSize = 4;//quaterion x,y,z,w
					info.m_uSize = 3;
					break;
				}
				case ePlanarType:
				{
					info.m_qSize = 2;
					info.m_uSize = 2;
					break;
				}
				case ePrismaticType:
				case eRevoluteType:
				{
					info.m_qSize = 1;
					info.m_uSize = 1;
					break;
				}

				default:
				{
				}
			}
			return true;
		}
	}
	return false;
}

i32 PhysicsClientSharedMemory::getNumUserConstraints() const
{
	return m_data->m_userConstraintInfoMap.size();
}

i32 PhysicsClientSharedMemory::getUserConstraintInfo(i32 constraintUniqueId, struct b3UserConstraint& info) const
{
	b3UserConstraint* constraintPtr = m_data->m_userConstraintInfoMap[constraintUniqueId];
	if (constraintPtr)
	{
		info = *constraintPtr;
		return 1;
	}
	return 0;
}

i32 PhysicsClientSharedMemory::getUserConstraintId(i32 serialIndex) const
{
	if ((serialIndex >= 0) && (serialIndex < getNumUserConstraints()))
	{
		return m_data->m_userConstraintInfoMap.getKeyAtIndex(serialIndex).getUid1();
	}
	return -1;
}

PhysicsClientSharedMemory::PhysicsClientSharedMemory()

{
	m_data = new PhysicsClientSharedMemoryInternalData;

#ifdef _WIN32
	m_data->m_sharedMemory = new Win32SharedMemoryClient();
#else
	m_data->m_sharedMemory = new PosixSharedMemory();
#endif
	m_data->m_ownsSharedMemory = true;
}

PhysicsClientSharedMemory::~PhysicsClientSharedMemory()
{
if (m_data->m_isConnected)
	{
		disconnectSharedMemory();
	}
	resetData();

	for (i32 i = 0; i < m_data->m_profileTimingStringArray.size(); i++)
	{
		STxt** str = m_data->m_profileTimingStringArray.getAtIndex(i);
		if (str)
		{
			delete *str;
		}
	}
	m_data->m_profileTimingStringArray.clear();

	if (m_data->m_ownsSharedMemory)
	{
		delete m_data->m_sharedMemory;
	}
	delete m_data;
}

void PhysicsClientSharedMemory::removeCachedBody(i32 bodyUniqueId)
{
	BodyJointInfoCache** bodyJointsPtr = m_data->m_bodyJointMap[bodyUniqueId];
	if (bodyJointsPtr && *bodyJointsPtr)
	{
		for (i32 i = 0; i < (*bodyJointsPtr)->m_userDataIds.size(); i++)
		{
			i32k userDataId = (*bodyJointsPtr)->m_userDataIds[i];
			SharedMemoryUserData* userData = m_data->m_userDataMap[userDataId];
			m_data->m_userDataHandleLookup.remove(SharedMemoryUserDataHashKey(userData));
			m_data->m_userDataMap.remove(userDataId);
		}
		delete (*bodyJointsPtr);
		m_data->m_bodyJointMap.remove(bodyUniqueId);
	}
}

void PhysicsClientSharedMemory::clearCachedBodies()
{
	for (i32 i = 0; i < m_data->m_bodyJointMap.size(); i++)
	{
		BodyJointInfoCache** bodyJointsPtr = m_data->m_bodyJointMap.getAtIndex(i);
		if (bodyJointsPtr && *bodyJointsPtr)
		{
			delete (*bodyJointsPtr);
		}
	}
	m_data->m_bodyJointMap.clear();
}

void PhysicsClientSharedMemory::resetData()
{
	m_data->m_debugLinesFrom.clear();
	m_data->m_debugLinesTo.clear();
	m_data->m_debugLinesColor.clear();
	m_data->m_userConstraintInfoMap.clear();
	m_data->m_userDataMap.clear();
	m_data->m_userDataHandleLookup.clear();
	clearCachedBodies();
}
void PhysicsClientSharedMemory::setSharedMemoryKey(i32 key)
{
	m_data->m_sharedMemoryKey = key;
}

void PhysicsClientSharedMemory::setSharedMemoryInterface(class SharedMemoryInterface* sharedMem)
{
	if (sharedMem)
	{
		if (m_data->m_sharedMemory && m_data->m_ownsSharedMemory)
		{
			delete m_data->m_sharedMemory;
		}
		m_data->m_ownsSharedMemory = false;
		m_data->m_sharedMemory = sharedMem;
	};
}

void PhysicsClientSharedMemory::disconnectSharedMemory()
{
	if (m_data->m_isConnected && m_data->m_sharedMemory)
	{
		m_data->m_sharedMemory->releaseSharedMemory(m_data->m_sharedMemoryKey, SHARED_MEMORY_SIZE);
	}
	m_data->m_isConnected = false;
}

bool PhysicsClientSharedMemory::isConnected() const
{
	return m_data->m_isConnected && (m_data->m_testBlock1->m_magicId == SHARED_MEMORY_MAGIC_NUMBER);
}

bool PhysicsClientSharedMemory::connect()
{
	/// server always has to create and initialize shared memory
	bool allowCreation = false;
	m_data->m_testBlock1 = (SharedMemoryBlock*)m_data->m_sharedMemory->allocateSharedMemory(
		m_data->m_sharedMemoryKey, SHARED_MEMORY_SIZE, allowCreation);

	if (m_data->m_testBlock1)
	{
		if (m_data->m_testBlock1->m_magicId != SHARED_MEMORY_MAGIC_NUMBER)
		{
			//there is no chance people are still using this software 100 years from now ;-)
			if ((m_data->m_testBlock1->m_magicId < 211705023) &&
				(m_data->m_testBlock1->m_magicId >= 201705023))
			{
				drx3DError("Ошибка: physics server version mismatch (expected %d got %d)\n", SHARED_MEMORY_MAGIC_NUMBER, m_data->m_testBlock1->m_magicId);
			}
			else
			{
				drx3DError("Error connecting to shared memory: please start server before client\n");
			}
			m_data->m_sharedMemory->releaseSharedMemory(m_data->m_sharedMemoryKey,
														SHARED_MEMORY_SIZE);
			m_data->m_testBlock1 = 0;
			return false;
		}
		else
		{
			if (m_data->m_verboseOutput)
			{
				drx3DPrintf("Connected to existing shared memory, status OK.\n");
			}
			m_data->m_isConnected = true;
		}
	}
	else
	{
		//drx3DWarning("Cannot connect to shared memory");
		return false;
	}
#if 0
	if (m_data->m_isConnected)
	{
		//get all existing bodies and body info...

		SharedMemoryCommand& command = m_data->m_testBlock1->m_clientCommands[0];
		//now transfer the information of the individual objects etc.
		command.m_type = CMD_REQUEST_BODY_INFO;
		command.m_sdfRequestInfoArgs.m_bodyUniqueId = 37;
		submitClientCommand(command);

		double startTime = clock.getTimeInSeconds();
		double timeOutInSeconds = 10;

		const SharedMemoryStatus* status = 0;

		while ((status == 0) && (clock.getTimeInSeconds()-startTime < timeOutInSeconds))
		{
			status = processServerStatus();
		
		}


		//submitClientCommand(command);


	}
#endif
	return true;
}

///todo(erwincoumans) refactor this: merge with PhysicsDirect::processBodyJointInfo
void PhysicsClientSharedMemory::processBodyJointInfo(i32 bodyUniqueId, const SharedMemoryStatus& serverCmd)
{
	bParse::BulletFile bf(
		&this->m_data->m_testBlock1->m_bulletStreamDataServerToClientRefactor[0],
		serverCmd.m_numDataStreamBytes);
	bf.setFileDNAisMemoryDNA();
	bf.parse(false);

	BodyJointInfoCache* bodyJoints = new BodyJointInfoCache;
	m_data->m_bodyJointMap.insert(bodyUniqueId, bodyJoints);
	bodyJoints->m_bodyName = serverCmd.m_dataStreamArguments.m_bodyName;

	for (i32 i = 0; i < bf.m_multiBodies.size(); i++)
	{
		i32 flag = bf.getFlags();
		if ((flag & bParse::FD_DOUBLE_PRECISION) != 0)
		{
			MultiBodyDoubleData* mb =
				(MultiBodyDoubleData*)bf.m_multiBodies[i];

			bodyJoints->m_baseName = mb->m_baseName;
			addJointInfoFromMultiBodyData(mb, bodyJoints, m_data->m_verboseOutput);
		}
		else
		{
			MultiBodyFloatData* mb =
				(MultiBodyFloatData*)bf.m_multiBodies[i];
			bodyJoints->m_baseName = mb->m_baseName;
			addJointInfoFromMultiBodyData(mb, bodyJoints, m_data->m_verboseOutput);
		}
	}
	if (bf.ok())
	{
		if (m_data->m_verboseOutput)
		{
			drx3DPrintf("Received robot description ok!\n");
		}
	}
	else
	{
		drx3DWarning("Robot description not received");
	}
}

template <typename T, typename U>
void addJointInfoFromConstraint(i32 linkIndex, const T* con, U* bodyJoints, bool verboseOutput)
{
	b3JointInfo info;
	info.m_jointName[0] = 0;
	info.m_linkName[0] = 0;
	info.m_flags = 0;
	info.m_jointIndex = linkIndex;
	info.m_qIndex = linkIndex + 7;
	info.m_uIndex = linkIndex + 6;
	//derive type from limits

	if (con->m_typeConstraintData.m_name)
	{
		strcpy(info.m_jointName, con->m_typeConstraintData.m_name);

		//info.m_linkName = strDup(con->m_typeConstraintData.m_name);
	}

	Vec3 linearLowerLimit(con->m_linearLowerLimit.m_floats[0], con->m_linearLowerLimit.m_floats[1], con->m_linearLowerLimit.m_floats[2]);
	Vec3 linearUpperLimit(con->m_linearUpperLimit.m_floats[0], con->m_linearUpperLimit.m_floats[1], con->m_linearUpperLimit.m_floats[2]);
	Vec3 angularLowerLimit(con->m_angularLowerLimit.m_floats[0], con->m_angularLowerLimit.m_floats[1], con->m_angularLowerLimit.m_floats[2]);
	Vec3 angularUpperLimit(con->m_angularUpperLimit.m_floats[0], con->m_angularUpperLimit.m_floats[1], con->m_angularUpperLimit.m_floats[2]);

	//very simple, rudimentary extraction of constaint type, from limits
	info.m_jointType = eFixedType;
	info.m_jointDamping = 0;      //mb->m_links[link].m_jointDamping;
	info.m_jointFriction = 0;     //mb->m_links[link].m_jointFriction;
	info.m_jointLowerLimit = 0;   //mb->m_links[link].m_jointLowerLimit;
	info.m_jointUpperLimit = 0;   //mb->m_links[link].m_jointUpperLimit;
	info.m_jointMaxForce = 0;     //mb->m_links[link].m_jointMaxForce;
	info.m_jointMaxVelocity = 0;  //mb->m_links[link].m_jointMaxVelocity;

	if (linearLowerLimit.isZero() && linearUpperLimit.isZero() && angularLowerLimit.isZero() && angularUpperLimit.isZero())
	{
		info.m_jointType = eFixedType;
	}
	else
	{
		if (linearLowerLimit.isZero() && linearUpperLimit.isZero())
		{
			info.m_jointType = eRevoluteType;
			Vec3 limitRange = angularLowerLimit.absolute() + angularUpperLimit.absolute();
			i32 limitAxis = limitRange.maxAxis();
			info.m_jointLowerLimit = angularLowerLimit[limitAxis];
			info.m_jointUpperLimit = angularUpperLimit[limitAxis];
		}
		else
		{
			info.m_jointType = ePrismaticType;
			Vec3 limitRange = linearLowerLimit.absolute() + linearUpperLimit.absolute();
			i32 limitAxis = limitRange.maxAxis();
			info.m_jointLowerLimit = linearLowerLimit[limitAxis];
			info.m_jointUpperLimit = linearUpperLimit[limitAxis];
		}
	}

	//if (mb->m_links[link].m_linkName) {

	if ((info.m_jointType == eRevoluteType) ||
		(info.m_jointType == ePrismaticType))
	{
		info.m_flags |= JOINT_HAS_MOTORIZED_POWER;
	}
	bodyJoints->m_jointInfo.push_back(info);
};

const SharedMemoryStatus* PhysicsClientSharedMemory::processServerStatus()
{
	// SharedMemoryStatus* stat = 0;

	if (!m_data->m_testBlock1)
	{
		m_data->m_lastServerStatus.m_type = CMD_SHARED_MEMORY_NOT_INITIALIZED;
		return &m_data->m_lastServerStatus;
	}

	if (!m_data->m_waitingForServer)
	{
		return 0;
	}

	if (m_data->m_testBlock1->m_magicId != SHARED_MEMORY_MAGIC_NUMBER)
	{
		m_data->m_lastServerStatus.m_type = CMD_SHARED_MEMORY_NOT_INITIALIZED;
		return &m_data->m_lastServerStatus;
	}

	if (m_data->m_testBlock1->m_numServerCommands >
		m_data->m_testBlock1->m_numProcessedServerCommands)
	{
		D3_PROFILE("processServerCMD");
		Assert(m_data->m_testBlock1->m_numServerCommands ==
				 m_data->m_testBlock1->m_numProcessedServerCommands + 1);

		const SharedMemoryStatus& serverCmd = m_data->m_testBlock1->m_serverCommands[0];

		if (serverCmd.m_type==CMD_ACTUAL_STATE_UPDATE_COMPLETED)
		{
			SendActualStateSharedMemoryStorage* serverState = (SendActualStateSharedMemoryStorage*)m_data->m_testBlock1->m_bulletStreamDataServerToClientRefactor;
			m_data->m_cachedState = *serverState;
			//ideally we provided a 'getCachedState' but that would require changing the API, so we store a pointer instead.
			m_data->m_testBlock1->m_serverCommands[0].m_sendActualStateArgs.m_stateDetails = &m_data->m_cachedState;
		}

		m_data->m_lastServerStatus = serverCmd;

		//       EnumSharedMemoryServerStatus s = (EnumSharedMemoryServerStatus)serverCmd.m_type;
		// consume the command

		switch (serverCmd.m_type)
		{
			case CMD_CLIENT_COMMAND_COMPLETED:
			{
				D3_PROFILE("CMD_CLIENT_COMMAND_COMPLETED");

				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("Server completed command");
				}
				break;
			}

			case CMD_MJCF_LOADING_COMPLETED:
			{
				D3_PROFILE("CMD_MJCF_LOADING_COMPLETED");

				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("Server loading the MJCF OK\n");
				}
				break;
			}
			case CMD_SDF_LOADING_COMPLETED:
			{
				D3_PROFILE("CMD_SDF_LOADING_COMPLETED");

				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("Server loading the SDF OK\n");
				}

				break;
			}

			case CMD_CREATE_MULTI_BODY_COMPLETED:
			case CMD_URDF_LOADING_COMPLETED:
			{
				D3_PROFILE("CMD_URDF_LOADING_COMPLETED");

				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("Server loading the URDF OK\n");
				}

				if (serverCmd.m_numDataStreamBytes > 0)
				{
					bParse::BulletFile bf(
						this->m_data->m_testBlock1->m_bulletStreamDataServerToClientRefactor,
						serverCmd.m_numDataStreamBytes);
					bf.setFileDNAisMemoryDNA();
					bf.parse(false);
					i32 bodyUniqueId = serverCmd.m_dataStreamArguments.m_bodyUniqueId;

					BodyJointInfoCache* bodyJoints = new BodyJointInfoCache;
					m_data->m_bodyJointMap.insert(bodyUniqueId, bodyJoints);
					bodyJoints->m_bodyName = serverCmd.m_dataStreamArguments.m_bodyName;

					for (i32 i = 0; i < bf.m_constraints.size(); i++)
					{
						i32 flag = bf.getFlags();

						if ((flag & bParse::FD_DOUBLE_PRECISION) != 0)
						{
							Generic6DofSpring2ConstraintDoubleData2* con =
								(Generic6DofSpring2ConstraintDoubleData2*)bf.m_constraints[i];
							addJointInfoFromConstraint(i, con, bodyJoints, m_data->m_verboseOutput);
						}
						else
						{
							Generic6DofSpring2ConstraintData* con =
								(Generic6DofSpring2ConstraintData*)bf.m_constraints[i];
							addJointInfoFromConstraint(i, con, bodyJoints, m_data->m_verboseOutput);
						}
					}

					for (i32 i = 0; i < bf.m_multiBodies.size(); i++)
					{
						i32 flag = bf.getFlags();

						if ((flag & bParse::FD_DOUBLE_PRECISION) != 0)
						{
							MultiBodyDoubleData* mb =
								(MultiBodyDoubleData*)bf.m_multiBodies[i];
							if (mb->m_baseName)
							{
								bodyJoints->m_baseName = mb->m_baseName;
							}
							addJointInfoFromMultiBodyData(mb, bodyJoints, m_data->m_verboseOutput);
						}
						else
						{
							MultiBodyFloatData* mb =
								(MultiBodyFloatData*)bf.m_multiBodies[i];
							if (mb->m_baseName)
							{
								bodyJoints->m_baseName = mb->m_baseName;
							}
							addJointInfoFromMultiBodyData(mb, bodyJoints, m_data->m_verboseOutput);
						}
					}
					if (bf.ok())
					{
						if (m_data->m_verboseOutput)
						{
							drx3DPrintf("Received robot description ok!\n");
						}
					}
					else
					{
						drx3DWarning("Robot description not received");
					}
				}
				break;
			}
			case CMD_DESIRED_STATE_RECEIVED_COMPLETED:
			{
				D3_PROFILE("CMD_DESIRED_STATE_RECEIVED_COMPLETED");

				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("Server received desired state");
				}
				break;
			}
			case CMD_STEP_FORWARD_SIMULATION_COMPLETED:
			{
				D3_PROFILE("CMD_STEP_FORWARD_SIMULATION_COMPLETED");

				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("Server completed step simulation");
				}
				break;
			}
			case CMD_PERFORM_COLLISION_DETECTION_COMPLETED:
			{
				D3_PROFILE("CMD_PERFORM_COLLISION_DETECTION_COMPLETED");

				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("Server completed performing collision detection");
				}
				break;
			}
			case CMD_URDF_LOADING_FAILED:
			{
				D3_PROFILE("CMD_URDF_LOADING_FAILED");

				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("Server failed loading the URDF...\n");
				}

				break;
			}
			case CMD_USER_CONSTRAINT_REQUEST_STATE_COMPLETED:
			{
				break;
			}
			case CMD_USER_CONSTRAINT_INFO_COMPLETED:
			{
				D3_PROFILE("CMD_USER_CONSTRAINT_INFO_COMPLETED");

				i32 cid = serverCmd.m_userConstraintResultArgs.m_userConstraintUniqueId;
				m_data->m_userConstraintInfoMap.insert(cid, serverCmd.m_userConstraintResultArgs);
				break;
			}
			case CMD_USER_CONSTRAINT_COMPLETED:
			{
				D3_PROFILE("CMD_USER_CONSTRAINT_COMPLETED");
				i32 cid = serverCmd.m_userConstraintResultArgs.m_userConstraintUniqueId;
				m_data->m_userConstraintInfoMap.insert(cid, serverCmd.m_userConstraintResultArgs);
				break;
			}
			case CMD_REMOVE_USER_CONSTRAINT_COMPLETED:
			{
				D3_PROFILE("CMD_REMOVE_USER_CONSTRAINT_COMPLETED");
				i32 cid = serverCmd.m_userConstraintResultArgs.m_userConstraintUniqueId;
				m_data->m_userConstraintInfoMap.remove(cid);
				break;
			}
			case CMD_CHANGE_USER_CONSTRAINT_COMPLETED:
			{
				D3_PROFILE("CMD_CHANGE_USER_CONSTRAINT_COMPLETED");

				i32 cid = serverCmd.m_userConstraintResultArgs.m_userConstraintUniqueId;
				b3UserConstraint* userConstraintPtr = m_data->m_userConstraintInfoMap[cid];
				if (userConstraintPtr)
				{
					const b3UserConstraint* serverConstraint = &serverCmd.m_userConstraintResultArgs;
					if (serverCmd.m_updateFlags & USER_CONSTRAINT_CHANGE_PIVOT_IN_B)
					{
						userConstraintPtr->m_childFrame[0] = serverConstraint->m_childFrame[0];
						userConstraintPtr->m_childFrame[1] = serverConstraint->m_childFrame[1];
						userConstraintPtr->m_childFrame[2] = serverConstraint->m_childFrame[2];
					}
					if (serverCmd.m_updateFlags & USER_CONSTRAINT_CHANGE_FRAME_ORN_IN_B)
					{
						userConstraintPtr->m_childFrame[3] = serverConstraint->m_childFrame[3];
						userConstraintPtr->m_childFrame[4] = serverConstraint->m_childFrame[4];
						userConstraintPtr->m_childFrame[5] = serverConstraint->m_childFrame[5];
						userConstraintPtr->m_childFrame[6] = serverConstraint->m_childFrame[6];
					}
					if (serverCmd.m_updateFlags & USER_CONSTRAINT_CHANGE_MAX_FORCE)
					{
						userConstraintPtr->m_maxAppliedForce = serverConstraint->m_maxAppliedForce;
					}
					if (serverCmd.m_updateFlags & USER_CONSTRAINT_CHANGE_GEAR_RATIO)
					{
						userConstraintPtr->m_gearRatio = serverConstraint->m_gearRatio;
					}
					if (serverCmd.m_updateFlags & USER_CONSTRAINT_CHANGE_RELATIVE_POSITION_TARGET)
					{
						userConstraintPtr->m_relativePositionTarget = serverConstraint->m_relativePositionTarget;
					}
					if (serverCmd.m_updateFlags & USER_CONSTRAINT_CHANGE_ERP)
					{
						userConstraintPtr->m_erp = serverConstraint->m_erp;
					}
					if (serverCmd.m_updateFlags & USER_CONSTRAINT_CHANGE_GEAR_AUX_LINK)
					{
						userConstraintPtr->m_gearAuxLink = serverConstraint->m_gearAuxLink;
					}
				}
				break;
			}

			case CMD_USER_CONSTRAINT_FAILED:
			{
				D3_PROFILE("CMD_USER_CONSTRAINT_FAILED");
				drx3DWarning("createConstraint failed");
				break;
			}
			case CMD_REMOVE_USER_CONSTRAINT_FAILED:
			{
				D3_PROFILE("CMD_REMOVE_USER_CONSTRAINT_FAILED");
				drx3DWarning("removeConstraint failed");
				break;
			}
			case CMD_CHANGE_USER_CONSTRAINT_FAILED:
			{
				D3_PROFILE("CMD_CHANGE_USER_CONSTRAINT_FAILED");
				//drx3DWarning("changeConstraint failed");
				break;
			}
			case CMD_ACTUAL_STATE_UPDATE_FAILED:
			{
				D3_PROFILE("CMD_ACTUAL_STATE_UPDATE_FAILED");
				drx3DWarning("request actual state failed");
				break;
			}
			case CMD_BODY_INFO_COMPLETED:
			{
				D3_PROFILE("CMD_BODY_INFO_COMPLETED");
				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("Received body info\n");
				}
				i32 bodyUniqueId = serverCmd.m_dataStreamArguments.m_bodyUniqueId;
				processBodyJointInfo(bodyUniqueId, serverCmd);

				break;
			}
			case CMD_MJCF_LOADING_FAILED:
			{
				D3_PROFILE("CMD_MJCF_LOADING_FAILED");
				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("Server failed loading the MJCF...\n");
				}
				break;
			}
			case CMD_SDF_LOADING_FAILED:
			{
				D3_PROFILE("CMD_SDF_LOADING_FAILED");
				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("Server failed loading the SDF...\n");
				}

				break;
			}

			case CMD_DRX3D_DATA_STREAM_RECEIVED_COMPLETED:
			{
				D3_PROFILE("CMD_DRX3D_DATA_STREAM_RECEIVED_COMPLETED");
				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("Server received bullet data stream OK\n");
				}

				break;
			}
			case CMD_DRX3D_DATA_STREAM_RECEIVED_FAILED:
			{
				D3_PROFILE("CMD_DRX3D_DATA_STREAM_RECEIVED_FAILED");
				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("Server failed receiving bullet data stream\n");
				}

				break;
			}

			case CMD_ACTUAL_STATE_UPDATE_COMPLETED:
			{
				D3_PROFILE("CMD_ACTUAL_STATE_UPDATE_COMPLETED");
				
				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("Received actual state\n");

					SharedMemoryStatus& command = m_data->m_testBlock1->m_serverCommands[0];

					i32 numQ = command.m_sendActualStateArgs.m_numDegreeOfFreedomQ;
					i32 numU = command.m_sendActualStateArgs.m_numDegreeOfFreedomU;
					drx3DPrintf("size Q = %d, size U = %d\n", numQ, numU);
					char msg[1024];
					{
						sprintf(msg, "Q=[");

						for (i32 i = 0; i < numQ; i++)
						{
							if (i < numQ - 1)
							{
								sprintf(msg, "%s%f,", msg,
									m_data->m_cachedState.m_actualStateQ[i]);
							}
							else
							{
								sprintf(msg, "%s%f", msg,
									m_data->m_cachedState.m_actualStateQ[i]);
							}
						}
						sprintf(msg, "%s]", msg);
					}
					drx3DPrintf(msg);

					sprintf(msg, "U=[");

					for (i32 i = 0; i < numU; i++)
					{
						if (i < numU - 1)
						{
							sprintf(msg, "%s%f,", msg,
								m_data->m_cachedState.m_actualStateQdot[i]);
						}
						else
						{
							sprintf(msg, "%s%f", msg,
								m_data->m_cachedState.m_actualStateQdot[i]);
						}
					}
					sprintf(msg, "%s]", msg);

					drx3DPrintf(msg);
					drx3DPrintf("\n");
				}
				break;
			}
			case CMD_RESET_SIMULATION_COMPLETED:
			{
				D3_PROFILE("CMD_RESET_SIMULATION_COMPLETED");
				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("CMD_RESET_SIMULATION_COMPLETED clean data\n");
				}
				resetData();

				break;
			}
			case CMD_DEBUG_LINES_COMPLETED:
			{
				D3_PROFILE("CMD_DEBUG_LINES_COMPLETED");
				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("Success receiving %d debug lines",
							 serverCmd.m_sendDebugLinesArgs.m_numDebugLines);
				}

				i32 numLines = serverCmd.m_sendDebugLinesArgs.m_numDebugLines;
				float* linesFrom =
					(float*)&m_data->m_testBlock1->m_bulletStreamDataServerToClientRefactor[0];
				float* linesTo =
					(float*)(&m_data->m_testBlock1->m_bulletStreamDataServerToClientRefactor[0] +
							 numLines * 3 * sizeof(float));
				float* linesColor =
					(float*)(&m_data->m_testBlock1->m_bulletStreamDataServerToClientRefactor[0] +
							 2 * numLines * 3 * sizeof(float));

				m_data->m_debugLinesFrom.resize(serverCmd.m_sendDebugLinesArgs.m_startingLineIndex +
												numLines);
				m_data->m_debugLinesTo.resize(serverCmd.m_sendDebugLinesArgs.m_startingLineIndex +
											  numLines);
				m_data->m_debugLinesColor.resize(
					serverCmd.m_sendDebugLinesArgs.m_startingLineIndex + numLines);

				for (i32 i = 0; i < numLines; i++)
				{
					TmpFloat3 from = CreateTmpFloat3(linesFrom[i * 3], linesFrom[i * 3 + 1],
													 linesFrom[i * 3 + 2]);
					TmpFloat3 to =
						CreateTmpFloat3(linesTo[i * 3], linesTo[i * 3 + 1], linesTo[i * 3 + 2]);
					TmpFloat3 color = CreateTmpFloat3(linesColor[i * 3], linesColor[i * 3 + 1],
													  linesColor[i * 3 + 2]);

					m_data
						->m_debugLinesFrom[serverCmd.m_sendDebugLinesArgs.m_startingLineIndex + i] =
						from;
					m_data->m_debugLinesTo[serverCmd.m_sendDebugLinesArgs.m_startingLineIndex + i] =
						to;
					m_data->m_debugLinesColor[serverCmd.m_sendDebugLinesArgs.m_startingLineIndex +
											  i] = color;
				}

				break;
			}
			case CMD_RIGID_BODY_CREATION_COMPLETED:
			{
				D3_PROFILE("CMD_RIGID_BODY_CREATION_COMPLETED");

				break;
			}
			case CMD_DEBUG_LINES_OVERFLOW_FAILED:
			{
				D3_PROFILE("CMD_DEBUG_LINES_OVERFLOW_FAILED");
				drx3DWarning("Error receiving debug lines");
				m_data->m_debugLinesFrom.resize(0);
				m_data->m_debugLinesTo.resize(0);
				m_data->m_debugLinesColor.resize(0);

				break;
			}

			case CMD_CAMERA_IMAGE_COMPLETED:
			{
				D3_PROFILE("CMD_CAMERA_IMAGE_COMPLETED");
				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("Camera image OK\n");
				}

				i32 numBytesPerPixel = 4;  //RGBA
				i32 numTotalPixels = serverCmd.m_sendPixelDataArguments.m_startingPixelIndex +
									 serverCmd.m_sendPixelDataArguments.m_numPixelsCopied +
									 serverCmd.m_sendPixelDataArguments.m_numRemainingPixels;

				m_data->m_cachedCameraPixelsWidth = 0;
				m_data->m_cachedCameraPixelsHeight = 0;

				i32 numPixels = serverCmd.m_sendPixelDataArguments.m_imageWidth * serverCmd.m_sendPixelDataArguments.m_imageHeight;

				m_data->m_cachedCameraPixelsRGBA.reserve(numPixels * numBytesPerPixel);
				m_data->m_cachedCameraDepthBuffer.resize(numTotalPixels);
				m_data->m_cachedSegmentationMaskBuffer.resize(numTotalPixels);
				m_data->m_cachedCameraPixelsRGBA.resize(numTotalPixels * numBytesPerPixel);

				u8* rgbaPixelsReceived =
					(u8*)&m_data->m_testBlock1->m_bulletStreamDataServerToClientRefactor[0];
				//  printf("pixel = %d\n", rgbaPixelsReceived[0]);

				float* depthBuffer = (float*)&(m_data->m_testBlock1->m_bulletStreamDataServerToClientRefactor[serverCmd.m_sendPixelDataArguments.m_numPixelsCopied * 4]);
				i32* segmentationMaskBuffer = (i32*)&(m_data->m_testBlock1->m_bulletStreamDataServerToClientRefactor[serverCmd.m_sendPixelDataArguments.m_numPixelsCopied * 8]);

				for (i32 i = 0; i < serverCmd.m_sendPixelDataArguments.m_numPixelsCopied; i++)
				{
					m_data->m_cachedCameraDepthBuffer[i + serverCmd.m_sendPixelDataArguments.m_startingPixelIndex] = depthBuffer[i];
				}

				for (i32 i = 0; i < serverCmd.m_sendPixelDataArguments.m_numPixelsCopied; i++)
				{
					m_data->m_cachedSegmentationMaskBuffer[i + serverCmd.m_sendPixelDataArguments.m_startingPixelIndex] = segmentationMaskBuffer[i];
				}

				for (i32 i = 0; i < serverCmd.m_sendPixelDataArguments.m_numPixelsCopied * numBytesPerPixel; i++)
				{
					m_data->m_cachedCameraPixelsRGBA[i + serverCmd.m_sendPixelDataArguments.m_startingPixelIndex * numBytesPerPixel] = rgbaPixelsReceived[i];
				}

				break;
			}

			case CMD_CAMERA_IMAGE_FAILED:
			{
				D3_PROFILE("CMD_CAMERA_IMAGE_FAILED");
				drx3DWarning("Camera image FAILED\n");
				break;
			}
			case CMD_REQUEST_MESH_DATA_COMPLETED:
			{
				m_data->m_cachedVertexPositions.resize(serverCmd.m_sendMeshDataArgs.m_startingVertex + serverCmd.m_sendMeshDataArgs.m_numVerticesCopied);
				Vec3* verticesReceived = (Vec3*)m_data->m_testBlock1->m_bulletStreamDataServerToClientRefactor;
				for (i32 i = 0; i < serverCmd.m_sendMeshDataArgs.m_numVerticesCopied; i++)
				{
					m_data->m_cachedVertexPositions[i + serverCmd.m_sendMeshDataArgs.m_startingVertex].x = verticesReceived[i].x();
					m_data->m_cachedVertexPositions[i + serverCmd.m_sendMeshDataArgs.m_startingVertex].y = verticesReceived[i].y();
					m_data->m_cachedVertexPositions[i + serverCmd.m_sendMeshDataArgs.m_startingVertex].z = verticesReceived[i].z();
					m_data->m_cachedVertexPositions[i + serverCmd.m_sendMeshDataArgs.m_startingVertex].w = verticesReceived[i].w();
				}
				break;
			}
			case CMD_REQUEST_MESH_DATA_FAILED:
			{
				drx3DWarning("Request mesh data failed");
				break;
			}
			case CMD_CALCULATED_INVERSE_DYNAMICS_COMPLETED:
			{
				break;
			}
			case CMD_CALCULATED_INVERSE_DYNAMICS_FAILED:
			{
				drx3DWarning("Inverse Dynamics computations failed");
				break;
			}
			case CMD_REQUEST_AABB_OVERLAP_FAILED:
			{
				drx3DWarning("Overlapping object query failed");
				break;
			}

			case CMD_REQUEST_RAY_CAST_INTERSECTIONS_COMPLETED:
			{
				D3_PROFILE("m_raycastHits");
				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("Raycast completed");
				}
				m_data->m_raycastHits.clear();
				b3RayHitInfo* rayHits = (b3RayHitInfo*)m_data->m_testBlock1->m_bulletStreamDataServerToClientRefactor;
				for (i32 i = 0; i < serverCmd.m_raycastHits.m_numRaycastHits; i++)
				{
					m_data->m_raycastHits.push_back(rayHits[i]);
				}
				break;
			}

			case CMD_REQUEST_VR_EVENTS_DATA_COMPLETED:
			{
				D3_PROFILE("CMD_REQUEST_VR_EVENTS_DATA_COMPLETED");
				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("Request VR Events completed");
				}
				m_data->m_cachedVREvents.clear();
				for (i32 i = 0; i < serverCmd.m_sendVREvents.m_numVRControllerEvents; i++)
				{
					m_data->m_cachedVREvents.push_back(serverCmd.m_sendVREvents.m_controllerEvents[i]);
				}
				break;
			}

			case CMD_REQUEST_KEYBOARD_EVENTS_DATA_COMPLETED:
			{
				D3_PROFILE("CMD_REQUEST_KEYBOARD_EVENTS_DATA_COMPLETED");
				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("Request keyboard events completed");
				}
				m_data->m_cachedKeyboardEvents.resize(serverCmd.m_sendKeyboardEvents.m_numKeyboardEvents);
				for (i32 i = 0; i < serverCmd.m_sendKeyboardEvents.m_numKeyboardEvents; i++)
				{
					m_data->m_cachedKeyboardEvents[i] = serverCmd.m_sendKeyboardEvents.m_keyboardEvents[i];
				}
				break;
			}

			case CMD_REQUEST_MOUSE_EVENTS_DATA_COMPLETED:
			{
				D3_PROFILE("CMD_REQUEST_MOUSE_EVENTS_DATA_COMPLETED");
				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("Request mouse events completed");
				}
				m_data->m_cachedMouseEvents.resize(serverCmd.m_sendMouseEvents.m_numMouseEvents);
				for (i32 i = 0; i < serverCmd.m_sendMouseEvents.m_numMouseEvents; i++)
				{
					m_data->m_cachedMouseEvents[i] = serverCmd.m_sendMouseEvents.m_mouseEvents[i];
				}
				break;
			}

			case CMD_REQUEST_AABB_OVERLAP_COMPLETED:
			{
				D3_PROFILE("CMD_REQUEST_AABB_OVERLAP_COMPLETED");
				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("Overlapping object request completed");
				}

				i32 startOverlapIndex = serverCmd.m_sendOverlappingObjectsArgs.m_startingOverlappingObjectIndex;
				i32 numOverlapCopied = serverCmd.m_sendOverlappingObjectsArgs.m_numOverlappingObjectsCopied;
				m_data->m_cachedOverlappingObjects.resize(startOverlapIndex + numOverlapCopied);
				b3OverlappingObject* objects = (b3OverlappingObject*)m_data->m_testBlock1->m_bulletStreamDataServerToClientRefactor;

				for (i32 i = 0; i < numOverlapCopied; i++)
				{
					m_data->m_cachedOverlappingObjects[startOverlapIndex + i] = objects[i];
				}

				break;
			}
			case CMD_CONTACT_POINT_INFORMATION_COMPLETED:
			{
				D3_PROFILE("CMD_CONTACT_POINT_INFORMATION_COMPLETED");
				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("Contact Point Information Request OK\n");
				}
				i32 startContactIndex = serverCmd.m_sendContactPointArgs.m_startingContactPointIndex;
				i32 numContactsCopied = serverCmd.m_sendContactPointArgs.m_numContactPointsCopied;

				m_data->m_cachedContactPoints.resize(startContactIndex + numContactsCopied);

				b3ContactPointData* contactData = (b3ContactPointData*)m_data->m_testBlock1->m_bulletStreamDataServerToClientRefactor;

				for (i32 i = 0; i < numContactsCopied; i++)
				{
					m_data->m_cachedContactPoints[startContactIndex + i] = contactData[i];
				}

				break;
			}
			case CMD_CONTACT_POINT_INFORMATION_FAILED:
			{
				D3_PROFILE("CMD_CONTACT_POINT_INFORMATION_FAILED");
				drx3DWarning("Contact Point Information Request failed");
				break;
			}

			case CMD_SAVE_WORLD_COMPLETED:
			{
				D3_PROFILE("CMD_SAVE_WORLD_COMPLETED");
				break;
			}

			case CMD_SAVE_WORLD_FAILED:
			{
				D3_PROFILE("CMD_SAVE_WORLD_FAILED");
				drx3DWarning("Saving world  failed");
				break;
			}
			case CMD_CALCULATE_INVERSE_KINEMATICS_COMPLETED:
			{
				D3_PROFILE("CMD_CALCULATE_INVERSE_KINEMATICS_COMPLETED");
				break;
			}
			case CMD_CALCULATE_INVERSE_KINEMATICS_FAILED:
			{
				D3_PROFILE("CMD_CALCULATE_INVERSE_KINEMATICS_FAILED");
				drx3DWarning("Calculate Inverse Kinematics Request failed");
				break;
			}
			case CMD_VISUAL_SHAPE_INFO_COMPLETED:
			{
				D3_PROFILE("CMD_VISUAL_SHAPE_INFO_COMPLETED");
				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("Visual Shape Information Request OK\n");
				}
				i32 startVisualShapeIndex = serverCmd.m_sendVisualShapeArgs.m_startingVisualShapeIndex;
				i32 numVisualShapesCopied = serverCmd.m_sendVisualShapeArgs.m_numVisualShapesCopied;
				m_data->m_cachedVisualShapes.resize(startVisualShapeIndex + numVisualShapesCopied);
				b3VisualShapeData* shapeData = (b3VisualShapeData*)m_data->m_testBlock1->m_bulletStreamDataServerToClientRefactor;
				for (i32 i = 0; i < numVisualShapesCopied; i++)
				{
					m_data->m_cachedVisualShapes[startVisualShapeIndex + i] = shapeData[i];
				}

				break;
			}
			case CMD_VISUAL_SHAPE_INFO_FAILED:
			{
				drx3DWarning("Visual Shape Info Request failed");
				break;
			}
			case CMD_VISUAL_SHAPE_UPDATE_COMPLETED:
			{
				break;
			}
			case CMD_VISUAL_SHAPE_UPDATE_FAILED:
			{
				drx3DWarning("Visual Shape Update failed");
				break;
			}
			case CMD_LOAD_TEXTURE_COMPLETED:
			{
				break;
			}
			case CMD_LOAD_TEXTURE_FAILED:
			{
				drx3DWarning("Load texture failed");
				break;
			}
			case CMD_DRX3D_LOADING_COMPLETED:
			{
				break;
			}
			case CMD_DRX3D_LOADING_FAILED:
			{
				drx3DWarning("Load .bullet failed");
				break;
			}
			case CMD_DRX3D_SAVING_FAILED:
			{
				drx3DWarning("Save .bullet failed");
				break;
			}
			case CMD_USER_DEBUG_DRAW_PARAMETER_COMPLETED:
			case CMD_USER_DEBUG_DRAW_COMPLETED:
			{
				break;
			}
			case CMD_USER_DEBUG_DRAW_FAILED:
			{
				drx3DWarning("User debug draw failed");
				break;
			}

			case CMD_SYNC_BODY_INFO_COMPLETED:
			{
				clearCachedBodies();
				break;
			}
			case CMD_STATE_LOGGING_START_COMPLETED:
			{
				break;
			};
			case CMD_STATE_LOGGING_COMPLETED:
			{
				break;
			};

			case CMD_STATE_LOGGING_FAILED:
			{
				drx3DWarning("State Logging failed");
				break;
			}
			case CMD_REQUEST_OPENGL_VISUALIZER_CAMERA_FAILED:
			{
				drx3DWarning("Request visualizer camera failed");
				break;
			}
			case CMD_REQUEST_OPENGL_VISUALIZER_CAMERA_COMPLETED:
			{
				break;
			}
			case CMD_REMOVE_BODY_COMPLETED:
			{
				break;
			}
			case CMD_REMOVE_BODY_FAILED:
			{
				drx3DWarning("Removing body failed");
				break;
			}
			case CMD_GET_DYNAMICS_INFO_COMPLETED:
			{
				break;
			}
			case CMD_GET_DYNAMICS_INFO_FAILED:
			{
				drx3DWarning("Request dynamics info failed");
				break;
			}
			case CMD_CREATE_COLLISION_SHAPE_FAILED:
			{
				drx3DWarning("Request createCollisionShape failed");
				break;
			}
			case CMD_CREATE_COLLISION_SHAPE_COMPLETED:
			case CMD_CREATE_VISUAL_SHAPE_COMPLETED:
			{
				break;
			}

			case CMD_CREATE_MULTI_BODY_FAILED:
			{
				drx3DWarning("Request createMultiBody failed");
				break;
			}
			case CMD_CREATE_VISUAL_SHAPE_FAILED:
			{
				drx3DWarning("Request createVisualShape failed");
				break;
			}
			case CMD_REQUEST_COLLISION_INFO_COMPLETED:
			{
				break;
			}
			case CMD_REQUEST_COLLISION_INFO_FAILED:
			{
				drx3DWarning("Request getCollisionInfo failed");
				break;
			}
			
			case CMD_CUSTOM_COMMAND_COMPLETED:
			{

				m_data->m_cachedReturnData.resize(serverCmd.m_customCommandResultArgs.m_returnDataSizeInBytes);
				m_data->m_cachedReturnDataValue.m_length = serverCmd.m_customCommandResultArgs.m_returnDataSizeInBytes;

				if (serverCmd.m_customCommandResultArgs.m_returnDataSizeInBytes)
				{
					m_data->m_cachedReturnDataValue.m_type = serverCmd.m_customCommandResultArgs.m_returnDataType;
					m_data->m_cachedReturnDataValue.m_data1 = &m_data->m_cachedReturnData[0];
					for (i32 i = 0; i < serverCmd.m_numDataStreamBytes; i++)
					{
						m_data->m_cachedReturnData[i + serverCmd.m_customCommandResultArgs.m_returnDataStart] = m_data->m_testBlock1->m_bulletStreamDataServerToClientRefactor[i];
					}
				}
				break;
			}
			case CMD_CALCULATED_JACOBIAN_COMPLETED:
			{
				break;
			}
			case CMD_CALCULATED_JACOBIAN_FAILED:
			{
				drx3DWarning("jacobian calculation failed");
				break;
			}
			case CMD_CUSTOM_COMMAND_FAILED:
			{
				drx3DWarning("custom plugin command failed");
				break;
			}

			case CMD_CALCULATED_MASS_MATRIX_FAILED:
			{
				drx3DWarning("calculate mass matrix failed");
				break;
			}
			case CMD_CALCULATED_MASS_MATRIX_COMPLETED:
			{
				double* matrixData = (double*)&this->m_data->m_testBlock1->m_bulletStreamDataServerToClientRefactor[0];
				m_data->m_cachedMassMatrix.resize(serverCmd.m_massMatrixResultArgs.m_dofCount * serverCmd.m_massMatrixResultArgs.m_dofCount);
				for (i32 i = 0; i < serverCmd.m_massMatrixResultArgs.m_dofCount * serverCmd.m_massMatrixResultArgs.m_dofCount; i++)
				{
					m_data->m_cachedMassMatrix[i] = matrixData[i];
				}
				break;
			}
			case CMD_REQUEST_PHYSICS_SIMULATION_PARAMETERS_COMPLETED:
			{
				break;
			}
			case CMD_SAVE_STATE_COMPLETED:
			{
				break;
			}
			case CMD_RESTORE_STATE_FAILED:
			{
				drx3DWarning("restoreState failed");
				break;
			}
			case CMD_RESTORE_STATE_COMPLETED:
			{
				break;
			}
			case CMD_DRX3D_SAVING_COMPLETED:
			{
				break;
			}
			case CMD_COLLISION_SHAPE_INFO_FAILED:
			{
				drx3DWarning("getCollisionShapeData failed");
				break;
			}
			case CMD_COLLISION_SHAPE_INFO_COMPLETED:
			{
				D3_PROFILE("CMD_COLLISION_SHAPE_INFO_COMPLETED");
				if (m_data->m_verboseOutput)
				{
					drx3DPrintf("Collision Shape Information Request OK\n");
				}
				i32 numCollisionShapesCopied = serverCmd.m_sendCollisionShapeArgs.m_numCollisionShapes;
				m_data->m_cachedCollisionShapes.resize(numCollisionShapesCopied);
				b3CollisionShapeData* shapeData = (b3CollisionShapeData*)m_data->m_testBlock1->m_bulletStreamDataServerToClientRefactor;
				for (i32 i = 0; i < numCollisionShapesCopied; i++)
				{
					m_data->m_cachedCollisionShapes[i] = shapeData[i];
				}
				break;
			}
			case CMD_LOAD_SOFT_BODY_FAILED:
			{
                            D3_PROFILE("CMD_LOAD_SOFT_BODY_FAILED");

                            if (m_data->m_verboseOutput)
                            {
                                drx3DPrintf("Server failed loading the SoftBody...\n");
                            }
                            break;
			}
			case CMD_LOAD_SOFT_BODY_COMPLETED:
			{
                          D3_PROFILE("CMD_LOAD_SOFT_BODY_COMPLETED");

                          if (m_data->m_verboseOutput)
                          {
                            drx3DPrintf("Server loading the SoftBody OK\n");
                          }
                          
                          drx3DAssert(serverCmd.m_numDataStreamBytes);
                          if (serverCmd.m_numDataStreamBytes > 0)
                          {
			       bParse::BulletFile bf(
                                   this->m_data->m_testBlock1->m_bulletStreamDataServerToClientRefactor,
                                   serverCmd.m_numDataStreamBytes);
                               bf.setFileDNAisMemoryDNA();
                               bf.parse(false);
                               i32 bodyUniqueId = serverCmd.m_dataStreamArguments.m_bodyUniqueId;
                               
                               BodyJointInfoCache* bodyJoints = new BodyJointInfoCache;
                               m_data->m_bodyJointMap.insert(bodyUniqueId, bodyJoints);
                               bodyJoints->m_bodyName = serverCmd.m_dataStreamArguments.m_bodyName;
                               bodyJoints->m_baseName = serverCmd.m_dataStreamArguments.m_bodyName;
                                        
                               if (bf.ok())
                               {
                                 if (m_data->m_verboseOutput)
                                 {
                                   drx3DPrintf("Received robot description ok!\n");
                                 }
                               }
                               else
                               {
                                 drx3DWarning("Robot description not received when loading soft body!");
                               }
                          }
                          break;
			}
			case CMD_SYNC_USER_DATA_FAILED:
			{
				drx3DWarning("Synchronizing user data failed.");
				break;
			}
			case CMD_REQUEST_USER_DATA_FAILED:
			{
				drx3DWarning("Requesting user data failed");
				break;
			}
			case CMD_ADD_USER_DATA_FAILED:
			{
				drx3DWarning("Adding user data failed (do the specified body and link exist?)");
				break;
			}
			case CMD_REMOVE_USER_DATA_FAILED:
			{
				drx3DWarning("Removing user data failed");
				break;
			}
			case CMD_RESET_MESH_DATA_FAILED:
			{
				drx3DWarning("resetMeshData failed");
				break;
			}
			case CMD_REQUEST_USER_DATA_COMPLETED:
			case CMD_SYNC_USER_DATA_COMPLETED:
			case CMD_REMOVE_USER_DATA_COMPLETED:
			case CMD_ADD_USER_DATA_COMPLETED:
			case CMD_REMOVE_STATE_FAILED:
			case CMD_REMOVE_STATE_COMPLETED:
			case CMD_RESET_MESH_DATA_COMPLETED:
			{
				break;
			}
			default:
			{
				drx3DError("Unknown server status %d\n", serverCmd.m_type);
				Assert(0);
			}
		};

		m_data->m_testBlock1->m_numProcessedServerCommands++;
		// we don't have more than 1 command outstanding (in total, either server or client)
		Assert(m_data->m_testBlock1->m_numProcessedServerCommands ==
				 m_data->m_testBlock1->m_numServerCommands);

		if (m_data->m_testBlock1->m_numServerCommands ==
			m_data->m_testBlock1->m_numProcessedServerCommands)
		{
			m_data->m_waitingForServer = false;
		}
		else
		{
			m_data->m_waitingForServer = true;
		}

		if ((serverCmd.m_type == CMD_SDF_LOADING_COMPLETED) || (serverCmd.m_type == CMD_MJCF_LOADING_COMPLETED) || (serverCmd.m_type == CMD_SYNC_BODY_INFO_COMPLETED))
		{
			D3_PROFILE("CMD_LOADING_COMPLETED");
			i32 numConstraints = serverCmd.m_sdfLoadedArgs.m_numUserConstraints;
			i32 numBodies = serverCmd.m_sdfLoadedArgs.m_numBodies;
			if (serverCmd.m_type == CMD_SYNC_BODY_INFO_COMPLETED)
			{
				i32* ids = (i32*)m_data->m_testBlock1->m_bulletStreamDataServerToClientRefactor;
				i32* constraintUids = ids + numBodies;
				for (i32 i = 0; i < numConstraints; i++)
				{
					i32 constraintUid = constraintUids[i];
					m_data->m_constraintIdsRequestInfo.push_back(constraintUid);
				}
			}
			else
			{
				for (i32 i = 0; i < numConstraints; i++)
				{
					i32 constraintUid = serverCmd.m_sdfLoadedArgs.m_userConstraintUniqueIds[i];
					m_data->m_constraintIdsRequestInfo.push_back(constraintUid);
				}
			}
			
			if (numBodies > 0)
			{
				m_data->m_tempBackupServerStatus = m_data->m_lastServerStatus;

				if (serverCmd.m_type == CMD_SYNC_BODY_INFO_COMPLETED)
				{
					i32* bodyIds = (i32*)m_data->m_testBlock1->m_bulletStreamDataServerToClientRefactor;

					for (i32 i = 0; i < numBodies; i++)
					{
						m_data->m_bodyIdsRequestInfo.push_back(bodyIds[i]);
					}
				}
				else
				{
					for (i32 i = 0; i < numBodies; i++)
					{
						m_data->m_bodyIdsRequestInfo.push_back(serverCmd.m_sdfLoadedArgs.m_bodyUniqueIds[i]);
					}
				}

				i32 bodyId = m_data->m_bodyIdsRequestInfo[m_data->m_bodyIdsRequestInfo.size() - 1];
				m_data->m_bodyIdsRequestInfo.pop_back();

				SharedMemoryCommand& command = m_data->m_testBlock1->m_clientCommands[0];
				//now transfer the information of the individual objects etc.
				command.m_type = CMD_REQUEST_BODY_INFO;
				command.m_sdfRequestInfoArgs.m_bodyUniqueId = bodyId;
				submitClientCommand(command);
				return 0;
			}
		}

		if (serverCmd.m_type == CMD_SYNC_USER_DATA_COMPLETED)
		{
			D3_PROFILE("CMD_SYNC_USER_DATA_COMPLETED");
			if (serverCmd.m_syncUserDataArgs.m_clearCachedUserDataEntries) {
				// Remove all cached user data entries.
				for (i32 i = 0; i < m_data->m_bodyJointMap.size(); i++)
				{
					BodyJointInfoCache** bodyJointsPtr = m_data->m_bodyJointMap.getAtIndex(i);
					if (bodyJointsPtr && *bodyJointsPtr)
					{
						(*bodyJointsPtr)->m_userDataIds.clear();
					}
				}
				m_data->m_userDataMap.clear();
				m_data->m_userDataHandleLookup.clear();
			}
			i32k numIdentifiers = serverCmd.m_syncUserDataArgs.m_numUserDataIdentifiers;
			if (numIdentifiers > 0)
			{
				m_data->m_tempBackupServerStatus = m_data->m_lastServerStatus;

				i32k* identifiers = (i32*)m_data->m_testBlock1->m_bulletStreamDataServerToClientRefactor;
				m_data->m_userDataIdsRequestInfo.reserve(numIdentifiers - 1);
				// Store the identifiers that still need to be requested.
				for (i32 i = 0; i < numIdentifiers - 1; i++)
				{
					m_data->m_userDataIdsRequestInfo.push_back(identifiers[i]);
				}

				// Request individual user data entries, start with last identifier.
				SharedMemoryCommand& command = m_data->m_testBlock1->m_clientCommands[0];
				command.m_type = CMD_REQUEST_USER_DATA;
				command.m_userDataRequestArgs.m_userDataId = identifiers[numIdentifiers - 1];
				submitClientCommand(command);
				return 0;
			}
		}

		if (serverCmd.m_type == CMD_ADD_USER_DATA_COMPLETED || serverCmd.m_type == CMD_REQUEST_USER_DATA_COMPLETED)
		{
			D3_PROFILE("CMD_ADD_USER_DATA_COMPLETED");
			const UserDataResponseArgs response = serverCmd.m_userDataResponseArgs;
			BodyJointInfoCache** bodyJointsPtr = m_data->m_bodyJointMap[response.m_bodyUniqueId];
			if (bodyJointsPtr && *bodyJointsPtr)
			{
				tukk dataStream = m_data->m_testBlock1->m_bulletStreamDataServerToClientRefactor;
				SharedMemoryUserData* userData = m_data->m_userDataMap[response.m_userDataId];
				if (userData)
				{
					// Only replace the value.
					userData->replaceValue(dataStream, response.m_valueLength, response.m_valueType);
				}
				else
				{
					// Add a new user data entry.
					tukk key = response.m_key;
					m_data->m_userDataMap.insert(response.m_userDataId, SharedMemoryUserData(key, response.m_bodyUniqueId, response.m_linkIndex, response.m_visualShapeIndex));
					userData = m_data->m_userDataMap[response.m_userDataId];
					userData->replaceValue(dataStream, response.m_valueLength, response.m_valueType);
					m_data->m_userDataHandleLookup.insert(SharedMemoryUserDataHashKey(userData), response.m_userDataId);
					(*bodyJointsPtr)->m_userDataIds.push_back(response.m_userDataId);
				}
			}
		}

		if (serverCmd.m_type == CMD_REQUEST_USER_DATA_COMPLETED)
		{
			if (m_data->m_userDataIdsRequestInfo.size() > 0)
			{
				// Request individual user data entries.
				i32k userDataId = m_data->m_userDataIdsRequestInfo[m_data->m_userDataIdsRequestInfo.size() - 1];
				m_data->m_userDataIdsRequestInfo.pop_back();

				SharedMemoryCommand& command = m_data->m_testBlock1->m_clientCommands[0];
				command.m_type = CMD_REQUEST_USER_DATA;
				command.m_userDataRequestArgs.m_userDataId = userDataId;
				submitClientCommand(command);
				return 0;
			}
			m_data->m_lastServerStatus = m_data->m_tempBackupServerStatus;
		}

		
		if (serverCmd.m_type == CMD_REMOVE_USER_DATA_COMPLETED)
		{
			D3_PROFILE("CMD_REMOVE_USER_DATA_COMPLETED");
			i32k userDataId = serverCmd.m_removeUserDataResponseArgs.m_userDataId;
			SharedMemoryUserData* userData = m_data->m_userDataMap[userDataId];
			if (userData)
			{
				BodyJointInfoCache** bodyJointsPtr = m_data->m_bodyJointMap[userData->m_bodyUniqueId];
				if (bodyJointsPtr && *bodyJointsPtr)
				{
					(*bodyJointsPtr)->m_userDataIds.remove(userDataId);
				}
				m_data->m_userDataHandleLookup.remove(SharedMemoryUserDataHashKey(userData));
				m_data->m_userDataMap.remove(userDataId);
			}
		}

		if (serverCmd.m_type == CMD_REMOVE_BODY_COMPLETED)
		{
			for (i32 i = 0; i < serverCmd.m_removeObjectArgs.m_numBodies; i++)
			{
				i32 bodyUniqueId = serverCmd.m_removeObjectArgs.m_bodyUniqueIds[i];
				removeCachedBody(bodyUniqueId);
			}
			for (i32 i = 0; i < serverCmd.m_removeObjectArgs.m_numUserConstraints; i++)
			{
				i32 key = serverCmd.m_removeObjectArgs.m_userConstraintUniqueIds[i];
				m_data->m_userConstraintInfoMap.remove(key);
			}
		}

		if (serverCmd.m_type == CMD_USER_CONSTRAINT_INFO_COMPLETED)
		{
			D3_PROFILE("CMD_USER_CONSTRAINT_INFO_COMPLETED");

			if (m_data->m_constraintIdsRequestInfo.size())
			{
				i32 cid = m_data->m_constraintIdsRequestInfo[m_data->m_constraintIdsRequestInfo.size() - 1];
				m_data->m_constraintIdsRequestInfo.pop_back();
				SharedMemoryCommand& command = m_data->m_testBlock1->m_clientCommands[0];
				command.m_type = CMD_USER_CONSTRAINT;
				command.m_updateFlags = USER_CONSTRAINT_REQUEST_INFO;
				command.m_userConstraintArguments.m_userConstraintUniqueId = cid;
				submitClientCommand(command);
				return 0;
			}
			else
			{
				m_data->m_lastServerStatus = m_data->m_tempBackupServerStatus;
			}
		}

		if (serverCmd.m_type == CMD_BODY_INFO_COMPLETED)
		{
			D3_PROFILE("CMD_BODY_INFO_COMPLETED");
			//are there any bodies left to be processed?
			if (m_data->m_bodyIdsRequestInfo.size())
			{
				i32 bodyId = m_data->m_bodyIdsRequestInfo[m_data->m_bodyIdsRequestInfo.size() - 1];
				m_data->m_bodyIdsRequestInfo.pop_back();

				SharedMemoryCommand& command = m_data->m_testBlock1->m_clientCommands[0];
				//now transfer the information of the individual objects etc.
				command.m_type = CMD_REQUEST_BODY_INFO;
				command.m_sdfRequestInfoArgs.m_bodyUniqueId = bodyId;
				submitClientCommand(command);
				return 0;
			}
			else
			{
				if (m_data->m_constraintIdsRequestInfo.size())
				{
					i32 cid = m_data->m_constraintIdsRequestInfo[m_data->m_constraintIdsRequestInfo.size() - 1];
					m_data->m_constraintIdsRequestInfo.pop_back();
					SharedMemoryCommand& command = m_data->m_testBlock1->m_clientCommands[0];
					command.m_type = CMD_USER_CONSTRAINT;
					command.m_updateFlags = USER_CONSTRAINT_REQUEST_INFO;
					command.m_userConstraintArguments.m_userConstraintUniqueId = cid;
					submitClientCommand(command);
					return 0;
				}
				else
				{
					m_data->m_lastServerStatus = m_data->m_tempBackupServerStatus;
				}
			}
		}

		if (serverCmd.m_type == CMD_REQUEST_AABB_OVERLAP_COMPLETED)
		{
			D3_PROFILE("CMD_REQUEST_AABB_OVERLAP_COMPLETED2");
			SharedMemoryCommand& command = m_data->m_testBlock1->m_clientCommands[0];
			if (serverCmd.m_sendOverlappingObjectsArgs.m_numRemainingOverlappingObjects > 0 && serverCmd.m_sendOverlappingObjectsArgs.m_numOverlappingObjectsCopied)
			{
				command.m_type = CMD_REQUEST_AABB_OVERLAP;
				command.m_requestOverlappingObjectsArgs.m_startingOverlappingObjectIndex = serverCmd.m_sendOverlappingObjectsArgs.m_startingOverlappingObjectIndex + serverCmd.m_sendOverlappingObjectsArgs.m_numOverlappingObjectsCopied;
				submitClientCommand(command);
				return 0;
			}
		}

		if (serverCmd.m_type == CMD_CONTACT_POINT_INFORMATION_COMPLETED)
		{
			D3_PROFILE("CMD_CONTACT_POINT_INFORMATION_COMPLETED2");
			SharedMemoryCommand& command = m_data->m_testBlock1->m_clientCommands[0];
			if (serverCmd.m_sendContactPointArgs.m_numRemainingContactPoints > 0 && serverCmd.m_sendContactPointArgs.m_numContactPointsCopied)
			{
				command.m_type = CMD_REQUEST_CONTACT_POINT_INFORMATION;
				command.m_requestContactPointArguments.m_startingContactPointIndex = serverCmd.m_sendContactPointArgs.m_startingContactPointIndex + serverCmd.m_sendContactPointArgs.m_numContactPointsCopied;
				command.m_requestContactPointArguments.m_objectAIndexFilter = -1;
				command.m_requestContactPointArguments.m_objectBIndexFilter = -1;
				submitClientCommand(command);
				return 0;
			}
		}

		if (serverCmd.m_type == CMD_VISUAL_SHAPE_INFO_COMPLETED)
		{
			D3_PROFILE("CMD_VISUAL_SHAPE_INFO_COMPLETED2");
			SharedMemoryCommand& command = m_data->m_testBlock1->m_clientCommands[0];
			if (serverCmd.m_sendVisualShapeArgs.m_numRemainingVisualShapes > 0 && serverCmd.m_sendVisualShapeArgs.m_numVisualShapesCopied)
			{
				command.m_type = CMD_REQUEST_VISUAL_SHAPE_INFO;
				command.m_requestVisualShapeDataArguments.m_startingVisualShapeIndex = serverCmd.m_sendVisualShapeArgs.m_startingVisualShapeIndex + serverCmd.m_sendVisualShapeArgs.m_numVisualShapesCopied;
				command.m_requestVisualShapeDataArguments.m_bodyUniqueId = serverCmd.m_sendVisualShapeArgs.m_bodyUniqueId;
				submitClientCommand(command);
				return 0;
			}
		}

		if (serverCmd.m_type == CMD_CAMERA_IMAGE_COMPLETED)
		{
			D3_PROFILE("CMD_CAMERA_IMAGE_COMPLETED2");
			SharedMemoryCommand& command = m_data->m_testBlock1->m_clientCommands[0];

			if (serverCmd.m_sendPixelDataArguments.m_numRemainingPixels > 0 && serverCmd.m_sendPixelDataArguments.m_numPixelsCopied)
			{
				// continue requesting remaining pixels
				command.m_type = CMD_REQUEST_CAMERA_IMAGE_DATA;
				command.m_requestPixelDataArguments.m_startPixelIndex =
					serverCmd.m_sendPixelDataArguments.m_startingPixelIndex +
					serverCmd.m_sendPixelDataArguments.m_numPixelsCopied;
				submitClientCommand(command);
				return 0;
			}
			else
			{
				m_data->m_cachedCameraPixelsWidth = serverCmd.m_sendPixelDataArguments.m_imageWidth;
				m_data->m_cachedCameraPixelsHeight = serverCmd.m_sendPixelDataArguments.m_imageHeight;
			}
		}

		if (serverCmd.m_type == CMD_REQUEST_MESH_DATA_COMPLETED)
		{
			D3_PROFILE("CMD_REQUEST_MESH_DATA_COMPLETED");
			SharedMemoryCommand& command = m_data->m_testBlock1->m_clientCommands[0];

			if (serverCmd.m_sendMeshDataArgs.m_numVerticesRemaining > 0 && serverCmd.m_sendMeshDataArgs.m_numVerticesCopied)
			{
				command.m_type = CMD_REQUEST_MESH_DATA;
				command.m_requestMeshDataArgs.m_startingVertex =
					serverCmd.m_sendMeshDataArgs.m_startingVertex +
					serverCmd.m_sendMeshDataArgs.m_numVerticesCopied;
				submitClientCommand(command);
				return 0;
			}
			else
			{
				m_data->m_cachedMeshData.m_numVertices = serverCmd.m_sendMeshDataArgs.m_startingVertex + serverCmd.m_sendMeshDataArgs.m_numVerticesCopied;
			}
		}

		if ((serverCmd.m_type == CMD_DEBUG_LINES_COMPLETED) &&
			(serverCmd.m_sendDebugLinesArgs.m_numRemainingDebugLines > 0))
		{
			D3_PROFILE("CMD_DEBUG_LINES_COMPLETED2");
			SharedMemoryCommand& command = m_data->m_testBlock1->m_clientCommands[0];

			// continue requesting debug lines for drawing
			command.m_type = CMD_REQUEST_DEBUG_LINES;
			command.m_requestDebugLinesArguments.m_startingLineIndex =
				serverCmd.m_sendDebugLinesArgs.m_numDebugLines +
				serverCmd.m_sendDebugLinesArgs.m_startingLineIndex;
			submitClientCommand(command);
			return 0;
		}

		if (serverCmd.m_type == CMD_CUSTOM_COMMAND_COMPLETED)
		{
			i32 totalReceived = (serverCmd.m_numDataStreamBytes + serverCmd.m_customCommandResultArgs.m_returnDataStart);
			i32 remaining = serverCmd.m_customCommandResultArgs.m_returnDataSizeInBytes - totalReceived;
			
			if (remaining > 0)
			{
				// continue requesting return data
				SharedMemoryCommand& command = m_data->m_testBlock1->m_clientCommands[0];
				command.m_type = CMD_CUSTOM_COMMAND;
				command.m_customCommandArgs.m_startingReturnBytes =
					totalReceived;
				submitClientCommand(command);
				return 0;
			}
		}

		return &m_data->m_lastServerStatus;
	}
	else
	{
		if (m_data->m_verboseOutput)
		{
			D3_PROFILE("m_verboseOutput");

			drx3DPrintf("m_numServerStatus  = %d, processed = %d\n",
					 m_data->m_testBlock1->m_numServerCommands,
					 m_data->m_testBlock1->m_numProcessedServerCommands);
		}
	}
	return 0;
}

bool PhysicsClientSharedMemory::canSubmitCommand() const
{
	if (m_data->m_isConnected && !m_data->m_waitingForServer)
	{
		if (m_data->m_testBlock1->m_magicId == SHARED_MEMORY_MAGIC_NUMBER)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	return false;
}

struct SharedMemoryCommand* PhysicsClientSharedMemory::getAvailableSharedMemoryCommand()
{
	static i32 sequence = 0;
	m_data->m_testBlock1->m_clientCommands[0].m_sequenceNumber = sequence++;
	return &m_data->m_testBlock1->m_clientCommands[0];
}

bool PhysicsClientSharedMemory::submitClientCommand(const SharedMemoryCommand& command)
{
	/// at the moment we allow a maximum of 1 outstanding command, so we check for this
	// once the server processed the command and returns a status, we clear the flag
	// "m_data->m_waitingForServer" and allow submitting the next command

	if (!m_data->m_waitingForServer)
	{
		if (&m_data->m_testBlock1->m_clientCommands[0] != &command)
		{
			m_data->m_testBlock1->m_clientCommands[0] = command;
		}
		m_data->m_testBlock1->m_numClientCommands++;
		m_data->m_waitingForServer = true;
		return true;
	}
	return false;
}

void PhysicsClientSharedMemory::uploadBulletFileToSharedMemory(tukk data, i32 len)
{
	Assert(len < SHARED_MEMORY_MAX_STREAM_CHUNK_SIZE);
	if (len >= SHARED_MEMORY_MAX_STREAM_CHUNK_SIZE)
	{
		drx3DWarning("uploadBulletFileToSharedMemory %d exceeds max size %d\n", len,
				  SHARED_MEMORY_MAX_STREAM_CHUNK_SIZE);
	}
	else
	{
		for (i32 i = 0; i < len; i++)
		{
			//m_data->m_testBlock1->m_bulletStreamDataClientToServer[i] = data[i];
			m_data->m_testBlock1->m_bulletStreamDataServerToClientRefactor[i] = data[i];
		}
	}
}

void PhysicsClientSharedMemory::uploadRaysToSharedMemory(struct SharedMemoryCommand& command, const double* rayFromWorldArray, const double* rayToWorldArray, i32 numRays)
{
	i32 curNumStreamingRays = command.m_requestRaycastIntersections.m_numStreamingRays;
	i32 newNumRays = curNumStreamingRays + numRays;
	Assert(newNumRays < MAX_RAY_INTERSECTION_BATCH_SIZE_STREAMING);

	if (newNumRays < MAX_RAY_INTERSECTION_BATCH_SIZE_STREAMING)
	{
		for (i32 i = 0; i < numRays; i++)
		{
			b3RayData* rayDataStream = (b3RayData*)m_data->m_testBlock1->m_bulletStreamDataServerToClientRefactor;
			rayDataStream[curNumStreamingRays + i].m_rayFromPosition[0] = rayFromWorldArray[i * 3 + 0];
			rayDataStream[curNumStreamingRays + i].m_rayFromPosition[1] = rayFromWorldArray[i * 3 + 1];
			rayDataStream[curNumStreamingRays + i].m_rayFromPosition[2] = rayFromWorldArray[i * 3 + 2];
			rayDataStream[curNumStreamingRays + i].m_rayToPosition[0] = rayToWorldArray[i * 3 + 0];
			rayDataStream[curNumStreamingRays + i].m_rayToPosition[1] = rayToWorldArray[i * 3 + 1];
			rayDataStream[curNumStreamingRays + i].m_rayToPosition[2] = rayToWorldArray[i * 3 + 2];
			command.m_requestRaycastIntersections.m_numStreamingRays++;
		}
	}
}

void PhysicsClientSharedMemory::getCachedCameraImage(struct b3CameraImageData* cameraData)
{
	cameraData->m_pixelWidth = m_data->m_cachedCameraPixelsWidth;
	cameraData->m_pixelHeight = m_data->m_cachedCameraPixelsHeight;
	cameraData->m_depthValues = m_data->m_cachedCameraDepthBuffer.size() ? &m_data->m_cachedCameraDepthBuffer[0] : 0;
	cameraData->m_rgbColorData = m_data->m_cachedCameraPixelsRGBA.size() ? &m_data->m_cachedCameraPixelsRGBA[0] : 0;
	cameraData->m_segmentationMaskValues = m_data->m_cachedSegmentationMaskBuffer.size() ? &m_data->m_cachedSegmentationMaskBuffer[0] : 0;
}

void PhysicsClientSharedMemory::getCachedContactPointInformation(struct b3ContactInformation* contactPointData)
{
	contactPointData->m_numContactPoints = m_data->m_cachedContactPoints.size();
	contactPointData->m_contactPointData = contactPointData->m_numContactPoints ? &m_data->m_cachedContactPoints[0] : 0;
}

void PhysicsClientSharedMemory::getCachedOverlappingObjects(struct b3AABBOverlapData* overlappingObjects)
{
	overlappingObjects->m_numOverlappingObjects = m_data->m_cachedOverlappingObjects.size();
	overlappingObjects->m_overlappingObjects = m_data->m_cachedOverlappingObjects.size() ? &m_data->m_cachedOverlappingObjects[0] : 0;
}

void PhysicsClientSharedMemory::getCachedVREvents(struct b3VREventsData* vrEventsData)
{
	vrEventsData->m_numControllerEvents = m_data->m_cachedVREvents.size();
	vrEventsData->m_controllerEvents = vrEventsData->m_numControllerEvents ? &m_data->m_cachedVREvents[0] : 0;
}

void PhysicsClientSharedMemory::getCachedKeyboardEvents(struct b3KeyboardEventsData* keyboardEventsData)
{
	keyboardEventsData->m_numKeyboardEvents = m_data->m_cachedKeyboardEvents.size();
	keyboardEventsData->m_keyboardEvents = keyboardEventsData->m_numKeyboardEvents ? &m_data->m_cachedKeyboardEvents[0] : 0;
}

void PhysicsClientSharedMemory::getCachedMouseEvents(struct b3MouseEventsData* mouseEventsData)
{
	mouseEventsData->m_numMouseEvents = m_data->m_cachedMouseEvents.size();
	mouseEventsData->m_mouseEvents = mouseEventsData->m_numMouseEvents ? &m_data->m_cachedMouseEvents[0] : 0;
}

void PhysicsClientSharedMemory::getCachedRaycastHits(struct b3RaycastInformation* raycastHits)
{
	raycastHits->m_numRayHits = m_data->m_raycastHits.size();
	raycastHits->m_rayHits = raycastHits->m_numRayHits ? &m_data->m_raycastHits[0] : 0;
}

void PhysicsClientSharedMemory::getCachedMassMatrix(i32 dofCountCheck, double* massMatrix)
{
	i32 sz = dofCountCheck * dofCountCheck;
	if (sz == m_data->m_cachedMassMatrix.size())
	{
		for (i32 i = 0; i < sz; i++)
		{
			massMatrix[i] = m_data->m_cachedMassMatrix[i];
		}
	}
}

bool PhysicsClientSharedMemory::getCachedReturnData(b3UserDataValue* returnData)
{
	if (m_data->m_cachedReturnDataValue.m_length)
	{
		*returnData = m_data->m_cachedReturnDataValue;
		return true;
	}
	return false;

}
void PhysicsClientSharedMemory::getCachedVisualShapeInformation(struct b3VisualShapeInformation* visualShapesInfo)
{
	visualShapesInfo->m_numVisualShapes = m_data->m_cachedVisualShapes.size();
	visualShapesInfo->m_visualShapeData = visualShapesInfo->m_numVisualShapes ? &m_data->m_cachedVisualShapes[0] : 0;
}

void PhysicsClientSharedMemory::getCachedCollisionShapeInformation(struct b3CollisionShapeInformation* collisionShapesInfo)
{
	collisionShapesInfo->m_numCollisionShapes = m_data->m_cachedCollisionShapes.size();
	collisionShapesInfo->m_collisionShapeData = collisionShapesInfo->m_numCollisionShapes ? &m_data->m_cachedCollisionShapes[0] : 0;
}

void PhysicsClientSharedMemory::getCachedMeshData(struct b3MeshData* meshData)
{
	m_data->m_cachedMeshData.m_numVertices = m_data->m_cachedVertexPositions.size();
	
	m_data->m_cachedMeshData.m_vertices = m_data->m_cachedMeshData.m_numVertices ? &m_data->m_cachedVertexPositions[0] : 0;
	
	*meshData = m_data->m_cachedMeshData;
}

const float* PhysicsClientSharedMemory::getDebugLinesFrom() const
{
	if (m_data->m_debugLinesFrom.size())
	{
		return &m_data->m_debugLinesFrom[0].m_x;
	}
	return 0;
}
const float* PhysicsClientSharedMemory::getDebugLinesTo() const
{
	if (m_data->m_debugLinesTo.size())
	{
		return &m_data->m_debugLinesTo[0].m_x;
	}
	return 0;
}
const float* PhysicsClientSharedMemory::getDebugLinesColor() const
{
	if (m_data->m_debugLinesColor.size())
	{
		return &m_data->m_debugLinesColor[0].m_x;
	}
	return 0;
}
i32 PhysicsClientSharedMemory::getNumDebugLines() const { return m_data->m_debugLinesFrom.size(); }

void PhysicsClientSharedMemory::setTimeOut(double timeOutInSeconds)
{
	m_data->m_timeOutInSeconds = timeOutInSeconds;
}
double PhysicsClientSharedMemory::getTimeOut() const
{
	return m_data->m_timeOutInSeconds;
}

bool PhysicsClientSharedMemory::getCachedUserData(i32 userDataId, struct b3UserDataValue& valueOut) const
{
	SharedMemoryUserData* userDataPtr = m_data->m_userDataMap[userDataId];
	if (!userDataPtr)
	{
		return false;
	}
	valueOut.m_type = (userDataPtr)->m_type;
	valueOut.m_length = userDataPtr->m_bytes.size();
	valueOut.m_data1 = userDataPtr->m_bytes.size() ? &userDataPtr->m_bytes[0] : 0;
	return true;
}

i32 PhysicsClientSharedMemory::getCachedUserDataId(i32 bodyUniqueId, i32 linkIndex, i32 visualShapeIndex, tukk key) const
{
	i32* userDataId = m_data->m_userDataHandleLookup.find(SharedMemoryUserDataHashKey(key, bodyUniqueId, linkIndex, visualShapeIndex));
	if (!userDataId)
	{
		return -1;
	}
	return *userDataId;
}

i32 PhysicsClientSharedMemory::getNumUserData(i32 bodyUniqueId) const
{
	BodyJointInfoCache** bodyJointsPtr = m_data->m_bodyJointMap[bodyUniqueId];
	if (!bodyJointsPtr || !(*bodyJointsPtr))
	{
		return 0;
	}
	return (*bodyJointsPtr)->m_userDataIds.size();
}

void PhysicsClientSharedMemory::getUserDataInfo(i32 bodyUniqueId, i32 userDataIndex, tukk* keyOut, i32* userDataIdOut, i32* linkIndexOut, i32* visualShapeIndexOut) const
{
	BodyJointInfoCache** bodyJointsPtr = m_data->m_bodyJointMap[bodyUniqueId];
	if (!bodyJointsPtr || !(*bodyJointsPtr) || userDataIndex < 0 || userDataIndex > (*bodyJointsPtr)->m_userDataIds.size())
	{
		*keyOut = 0;
		*userDataIdOut = -1;
		return;
	}
	i32 userDataId = (*bodyJointsPtr)->m_userDataIds[userDataIndex];
	SharedMemoryUserData* userData = m_data->m_userDataMap[userDataId];

	*userDataIdOut = userDataId;
	*keyOut = userData->m_key.c_str();
	*linkIndexOut = userData->m_linkIndex;
	*visualShapeIndexOut = userData->m_visualShapeIndex;
}

void PhysicsClientSharedMemory::pushProfileTiming(tukk timingName)
{
	STxt** strPtr = m_data->m_profileTimingStringArray[timingName];
	STxt* str = 0;
	if (strPtr)
	{
		str = *strPtr;
	}
	else
	{
		str = new STxt(timingName);
		m_data->m_profileTimingStringArray.insert(timingName, str);
	}
	m_data->m_profileTimings.push_back(new CProfileSample(str->c_str()));
}

void PhysicsClientSharedMemory::popProfileTiming()
{
	if (m_data->m_profileTimings.size())
	{
		CProfileSample* sample = m_data->m_profileTimings[m_data->m_profileTimings.size() - 1];
		m_data->m_profileTimings.pop_back();
		delete sample;
	}
}

