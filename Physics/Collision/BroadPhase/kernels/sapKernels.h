//this file is autogenerated using stringify.bat (premake --stringify) in the build folder of this project
static tukk sapCL =
	"/*\n"
	"Copyright (c) 2012 Advanced Micro Devices, Inc.  \n"
	"This software is provided 'as-is', without any express or implied warranty.\n"
	"In no event will the authors be held liable for any damages arising from the use of this software.\n"
	"Permission is granted to anyone to use this software for any purpose, \n"
	"including commercial applications, and to alter it and redistribute it freely, \n"
	"subject to the following restrictions:\n"
	"1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.\n"
	"2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.\n"
	"3. This notice may not be removed or altered from any source distribution.\n"
	"*/\n"
	"//Originally written by Erwin Coumans\n"
	"#define NEW_PAIR_MARKER -1\n"
	"typedef struct \n"
	"{\n"
	"	union\n"
	"	{\n"
	"		float4	m_min;\n"
	"		float   m_minElems[4];\n"
	"		i32			m_minIndices[4];\n"
	"	};\n"
	"	union\n"
	"	{\n"
	"		float4	m_max;\n"
	"		float   m_maxElems[4];\n"
	"		i32			m_maxIndices[4];\n"
	"	};\n"
	"} AabbCL;\n"
	"/// conservative test for overlap between two aabbs\n"
	"bool TestAabbAgainstAabb2(const AabbCL* aabb1, __local const AabbCL* aabb2);\n"
	"bool TestAabbAgainstAabb2(const AabbCL* aabb1, __local const AabbCL* aabb2)\n"
	"{\n"
	"	bool overlap = true;\n"
	"	overlap = (aabb1->m_min.x > aabb2->m_max.x || aabb1->m_max.x < aabb2->m_min.x) ? false : overlap;\n"
	"	overlap = (aabb1->m_min.z > aabb2->m_max.z || aabb1->m_max.z < aabb2->m_min.z) ? false : overlap;\n"
	"	overlap = (aabb1->m_min.y > aabb2->m_max.y || aabb1->m_max.y < aabb2->m_min.y) ? false : overlap;\n"
	"	return overlap;\n"
	"}\n"
	"bool TestAabbAgainstAabb2GlobalGlobal(__global const AabbCL* aabb1, __global const AabbCL* aabb2);\n"
	"bool TestAabbAgainstAabb2GlobalGlobal(__global const AabbCL* aabb1, __global const AabbCL* aabb2)\n"
	"{\n"
	"	bool overlap = true;\n"
	"	overlap = (aabb1->m_min.x > aabb2->m_max.x || aabb1->m_max.x < aabb2->m_min.x) ? false : overlap;\n"
	"	overlap = (aabb1->m_min.z > aabb2->m_max.z || aabb1->m_max.z < aabb2->m_min.z) ? false : overlap;\n"
	"	overlap = (aabb1->m_min.y > aabb2->m_max.y || aabb1->m_max.y < aabb2->m_min.y) ? false : overlap;\n"
	"	return overlap;\n"
	"}\n"
	"bool TestAabbAgainstAabb2Global(const AabbCL* aabb1, __global const AabbCL* aabb2);\n"
	"bool TestAabbAgainstAabb2Global(const AabbCL* aabb1, __global const AabbCL* aabb2)\n"
	"{\n"
	"	bool overlap = true;\n"
	"	overlap = (aabb1->m_min.x > aabb2->m_max.x || aabb1->m_max.x < aabb2->m_min.x) ? false : overlap;\n"
	"	overlap = (aabb1->m_min.z > aabb2->m_max.z || aabb1->m_max.z < aabb2->m_min.z) ? false : overlap;\n"
	"	overlap = (aabb1->m_min.y > aabb2->m_max.y || aabb1->m_max.y < aabb2->m_min.y) ? false : overlap;\n"
	"	return overlap;\n"
	"}\n"
	"__kernel void   computePairsKernelTwoArrays( __global const AabbCL* unsortedAabbs, __global i32k* unsortedAabbMapping,  __global i32k* unsortedAabbMapping2,  __global int4* pairsOut,  __global i32* pairCount, i32 numUnsortedAabbs, i32 numUnSortedAabbs2, i32 axis, i32 maxPairs)\n"
	"{\n"
	"	i32 i = get_global_id(0);\n"
	"	if (i>=numUnsortedAabbs)\n"
	"		return;\n"
	"	i32 j = get_global_id(1);\n"
	"	if (j>=numUnSortedAabbs2)\n"
	"		return;\n"
	"	__global const AabbCL* unsortedAabbPtr = &unsortedAabbs[unsortedAabbMapping[i]];\n"
	"	__global const AabbCL* unsortedAabbPtr2 = &unsortedAabbs[unsortedAabbMapping2[j]];\n"
	"	if (TestAabbAgainstAabb2GlobalGlobal(unsortedAabbPtr,unsortedAabbPtr2))\n"
	"	{\n"
	"		int4 myPair;\n"
	"		\n"
	"		i32 xIndex = unsortedAabbPtr[0].m_minIndices[3];\n"
	"		i32 yIndex = unsortedAabbPtr2[0].m_minIndices[3];\n"
	"		if (xIndex>yIndex)\n"
	"		{\n"
	"			i32 tmp = xIndex;\n"
	"			xIndex=yIndex;\n"
	"			yIndex=tmp;\n"
	"		}\n"
	"		\n"
	"		myPair.x = xIndex;\n"
	"		myPair.y = yIndex;\n"
	"		myPair.z = NEW_PAIR_MARKER;\n"
	"		myPair.w = NEW_PAIR_MARKER;\n"
	"		i32 curPair = atomic_inc (pairCount);\n"
	"		if (curPair<maxPairs)\n"
	"		{\n"
	"				pairsOut[curPair] = myPair; //flush to main memory\n"
	"		}\n"
	"	}\n"
	"}\n"
	"__kernel void   computePairsKernelBruteForce( __global const AabbCL* aabbs,  __global int4* pairsOut,  __global i32* pairCount, i32 numObjects, i32 axis, i32 maxPairs)\n"
	"{\n"
	"	i32 i = get_global_id(0);\n"
	"	if (i>=numObjects)\n"
	"		return;\n"
	"	for (i32 j=i+1;j<numObjects;j++)\n"
	"	{\n"
	"		if (TestAabbAgainstAabb2GlobalGlobal(&aabbs[i],&aabbs[j]))\n"
	"		{\n"
	"			int4 myPair;\n"
	"			myPair.x = aabbs[i].m_minIndices[3];\n"
	"			myPair.y = aabbs[j].m_minIndices[3];\n"
	"			myPair.z = NEW_PAIR_MARKER;\n"
	"			myPair.w = NEW_PAIR_MARKER;\n"
	"			i32 curPair = atomic_inc (pairCount);\n"
	"			if (curPair<maxPairs)\n"
	"			{\n"
	"					pairsOut[curPair] = myPair; //flush to main memory\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"}\n"
	"__kernel void   computePairsKernelOriginal( __global const AabbCL* aabbs,  __global int4* pairsOut,  __global i32* pairCount, i32 numObjects, i32 axis, i32 maxPairs)\n"
	"{\n"
	"	i32 i = get_global_id(0);\n"
	"	if (i>=numObjects)\n"
	"		return;\n"
	"	for (i32 j=i+1;j<numObjects;j++)\n"
	"	{\n"
	"  	if(aabbs[i].m_maxElems[axis] < (aabbs[j].m_minElems[axis])) \n"
	"		{\n"
	"			break;\n"
	"		}\n"
	"		if (TestAabbAgainstAabb2GlobalGlobal(&aabbs[i],&aabbs[j]))\n"
	"		{\n"
	"			int4 myPair;\n"
	"			myPair.x = aabbs[i].m_minIndices[3];\n"
	"			myPair.y = aabbs[j].m_minIndices[3];\n"
	"			myPair.z = NEW_PAIR_MARKER;\n"
	"			myPair.w = NEW_PAIR_MARKER;\n"
	"			i32 curPair = atomic_inc (pairCount);\n"
	"			if (curPair<maxPairs)\n"
	"			{\n"
	"					pairsOut[curPair] = myPair; //flush to main memory\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"}\n"
	"__kernel void   computePairsKernelBarrier( __global const AabbCL* aabbs,  __global int4* pairsOut,  __global i32* pairCount, i32 numObjects, i32 axis, i32 maxPairs)\n"
	"{\n"
	"	i32 i = get_global_id(0);\n"
	"	i32 localId = get_local_id(0);\n"
	"	__local i32 numActiveWgItems[1];\n"
	"	__local i32 breakRequest[1];\n"
	"	if (localId==0)\n"
	"	{\n"
	"		numActiveWgItems[0] = 0;\n"
	"		breakRequest[0] = 0;\n"
	"	}\n"
	"	barrier(CLK_LOCAL_MEM_FENCE);\n"
	"	atomic_inc(numActiveWgItems);\n"
	"	barrier(CLK_LOCAL_MEM_FENCE);\n"
	"	i32 localBreak = 0;\n"
	"	i32 j=i+1;\n"
	"	do\n"
	"	{\n"
	"		barrier(CLK_LOCAL_MEM_FENCE);\n"
	"	\n"
	"		if (j<numObjects)\n"
	"		{\n"
	"	  	if(aabbs[i].m_maxElems[axis] < (aabbs[j].m_minElems[axis])) \n"
	"			{\n"
	"				if (!localBreak)\n"
	"				{\n"
	"					atomic_inc(breakRequest);\n"
	"					localBreak = 1;\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"		\n"
	"		barrier(CLK_LOCAL_MEM_FENCE);\n"
	"		\n"
	"		if (j>=numObjects && !localBreak)\n"
	"		{\n"
	"			atomic_inc(breakRequest);\n"
	"			localBreak = 1;\n"
	"		}\n"
	"		barrier(CLK_LOCAL_MEM_FENCE);\n"
	"		\n"
	"		if (!localBreak)\n"
	"		{\n"
	"			if (TestAabbAgainstAabb2GlobalGlobal(&aabbs[i],&aabbs[j]))\n"
	"			{\n"
	"				int4 myPair;\n"
	"				myPair.x = aabbs[i].m_minIndices[3];\n"
	"				myPair.y = aabbs[j].m_minIndices[3];\n"
	"				myPair.z = NEW_PAIR_MARKER;\n"
	"				myPair.w = NEW_PAIR_MARKER;\n"
	"				i32 curPair = atomic_inc (pairCount);\n"
	"				if (curPair<maxPairs)\n"
	"				{\n"
	"						pairsOut[curPair] = myPair; //flush to main memory\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"		j++;\n"
	"	} while (breakRequest[0]<numActiveWgItems[0]);\n"
	"}\n"
	"__kernel void   computePairsKernelLocalSharedMemory( __global const AabbCL* aabbs,  __global int4* pairsOut,  __global i32* pairCount, i32 numObjects, i32 axis, i32 maxPairs)\n"
	"{\n"
	"	i32 i = get_global_id(0);\n"
	"	i32 localId = get_local_id(0);\n"
	"	__local i32 numActiveWgItems[1];\n"
	"	__local i32 breakRequest[1];\n"
	"	__local AabbCL localAabbs[128];// = aabbs[i];\n"
	"	\n"
	"	AabbCL myAabb;\n"
	"	\n"
	"	myAabb = (i<numObjects)? aabbs[i]:aabbs[0];\n"
	"	float testValue = 	myAabb.m_maxElems[axis];\n"
	"	\n"
	"	if (localId==0)\n"
	"	{\n"
	"		numActiveWgItems[0] = 0;\n"
	"		breakRequest[0] = 0;\n"
	"	}\n"
	"	i32 localCount=0;\n"
	"	i32 block=0;\n"
	"	localAabbs[localId] = (i+block)<numObjects? aabbs[i+block] : aabbs[0];\n"
	"	localAabbs[localId+64] = (i+block+64)<numObjects? aabbs[i+block+64]: aabbs[0];\n"
	"	\n"
	"	barrier(CLK_LOCAL_MEM_FENCE);\n"
	"	atomic_inc(numActiveWgItems);\n"
	"	barrier(CLK_LOCAL_MEM_FENCE);\n"
	"	i32 localBreak = 0;\n"
	"	\n"
	"	i32 j=i+1;\n"
	"	do\n"
	"	{\n"
	"		barrier(CLK_LOCAL_MEM_FENCE);\n"
	"	\n"
	"		if (j<numObjects)\n"
	"		{\n"
	"	  	if(testValue < (localAabbs[localCount+localId+1].m_minElems[axis])) \n"
	"			{\n"
	"				if (!localBreak)\n"
	"				{\n"
	"					atomic_inc(breakRequest);\n"
	"					localBreak = 1;\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"		\n"
	"		barrier(CLK_LOCAL_MEM_FENCE);\n"
	"		\n"
	"		if (j>=numObjects && !localBreak)\n"
	"		{\n"
	"			atomic_inc(breakRequest);\n"
	"			localBreak = 1;\n"
	"		}\n"
	"		barrier(CLK_LOCAL_MEM_FENCE);\n"
	"		\n"
	"		if (!localBreak)\n"
	"		{\n"
	"			if (TestAabbAgainstAabb2(&myAabb,&localAabbs[localCount+localId+1]))\n"
	"			{\n"
	"				int4 myPair;\n"
	"				myPair.x = myAabb.m_minIndices[3];\n"
	"				myPair.y = localAabbs[localCount+localId+1].m_minIndices[3];\n"
	"				myPair.z = NEW_PAIR_MARKER;\n"
	"				myPair.w = NEW_PAIR_MARKER;\n"
	"				i32 curPair = atomic_inc (pairCount);\n"
	"				if (curPair<maxPairs)\n"
	"				{\n"
	"						pairsOut[curPair] = myPair; //flush to main memory\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"		\n"
	"		barrier(CLK_LOCAL_MEM_FENCE);\n"
	"		localCount++;\n"
	"		if (localCount==64)\n"
	"		{\n"
	"			localCount = 0;\n"
	"			block+=64;			\n"
	"			localAabbs[localId] = ((i+block)<numObjects) ? aabbs[i+block] : aabbs[0];\n"
	"			localAabbs[localId+64] = ((i+64+block)<numObjects) ? aabbs[i+block+64] : aabbs[0];\n"
	"		}\n"
	"		j++;\n"
	"		\n"
	"	} while (breakRequest[0]<numActiveWgItems[0]);\n"
	"	\n"
	"}\n"
	"//http://stereopsis.com/radix.html\n"
	"u32 FloatFlip(float fl);\n"
	"u32 FloatFlip(float fl)\n"
	"{\n"
	"	u32 f = *(u32*)&fl;\n"
	"	u32 mask = -(i32)(f >> 31) | 0x80000000;\n"
	"	return f ^ mask;\n"
	"}\n"
	"float IFloatFlip(u32 f);\n"
	"float IFloatFlip(u32 f)\n"
	"{\n"
	"	u32 mask = ((f >> 31) - 1) | 0x80000000;\n"
	"	u32 fl = f ^ mask;\n"
	"	return *(float*)&fl;\n"
	"}\n"
	"__kernel void   copyAabbsKernel( __global const AabbCL* allAabbs, __global AabbCL* destAabbs, i32 numObjects)\n"
	"{\n"
	"	i32 i = get_global_id(0);\n"
	"	if (i>=numObjects)\n"
	"		return;\n"
	"	i32 src = destAabbs[i].m_maxIndices[3];\n"
	"	destAabbs[i] = allAabbs[src];\n"
	"	destAabbs[i].m_maxIndices[3] = src;\n"
	"}\n"
	"__kernel void   flipFloatKernel( __global const AabbCL* allAabbs, __global i32k* smallAabbMapping, __global int2* sortData, i32 numObjects, i32 axis)\n"
	"{\n"
	"	i32 i = get_global_id(0);\n"
	"	if (i>=numObjects)\n"
	"		return;\n"
	"	\n"
	"	\n"
	"	sortData[i].x = FloatFlip(allAabbs[smallAabbMapping[i]].m_minElems[axis]);\n"
	"	sortData[i].y = i;\n"
	"		\n"
	"}\n"
	"__kernel void   scatterKernel( __global const AabbCL* allAabbs, __global i32k* smallAabbMapping,  __global const int2* sortData, __global AabbCL* sortedAabbs, i32 numObjects)\n"
	"{\n"
	"	i32 i = get_global_id(0);\n"
	"	if (i>=numObjects)\n"
	"		return;\n"
	"	\n"
	"	sortedAabbs[i] = allAabbs[smallAabbMapping[sortData[i].y]];\n"
	"}\n"
	"__kernel void   prepareSumVarianceKernel( __global const AabbCL* allAabbs, __global i32k* smallAabbMapping, __global float4* sum, __global float4* sum2,i32 numAabbs)\n"
	"{\n"
	"	i32 i = get_global_id(0);\n"
	"	if (i>=numAabbs)\n"
	"		return;\n"
	"	\n"
	"	AabbCL smallAabb = allAabbs[smallAabbMapping[i]];\n"
	"	\n"
	"	float4 s;\n"
	"	s = (smallAabb.m_max+smallAabb.m_min)*0.5f;\n"
	"	sum[i]=s;\n"
	"	sum2[i]=s*s;	\n"
	"}\n";
