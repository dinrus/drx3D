//this file is autogenerated using stringify.bat (premake --stringify) in the build folder of this project
static tukk bvhTraversalKernelCL =
	"//keep this enum in sync with the CPU version (in Collidable.h)\n"
	"//written by Erwin Coumans\n"
	"#define SHAPE_CONVEX_HULL 3\n"
	"#define SHAPE_CONCAVE_TRIMESH 5\n"
	"#define TRIANGLE_NUM_CONVEX_FACES 5\n"
	"#define SHAPE_COMPOUND_OF_CONVEX_HULLS 6\n"
	"#define SHAPE_SPHERE 7\n"
	"typedef u32 u32;\n"
	"#define MAX_NUM_PARTS_IN_BITS 10\n"
	"//QuantizedBvhNode is a compressed aabb node, 16 bytes.\n"
	"///Node can be used for leafnode or internal node. Leafnodes can point to 32-bit triangle index (non-negative range).\n"
	"typedef struct\n"
	"{\n"
	"	//12 bytes\n"
	"	u16	m_quantizedAabbMin[3];\n"
	"	u16	m_quantizedAabbMax[3];\n"
	"	//4 bytes\n"
	"	i32	m_escapeIndexOrTriangleIndex;\n"
	"} QuantizedBvhNode;\n"
	"typedef struct\n"
	"{\n"
	"	float4		m_aabbMin;\n"
	"	float4		m_aabbMax;\n"
	"	float4		m_quantization;\n"
	"	i32			m_numNodes;\n"
	"	i32			m_numSubTrees;\n"
	"	i32			m_nodeOffset;\n"
	"	i32			m_subTreeOffset;\n"
	"} b3BvhInfo;\n"
	"i32	getTriangleIndex(const QuantizedBvhNode* rootNode)\n"
	"{\n"
	"	u32 x=0;\n"
	"	u32 y = (~(x&0))<<(31-MAX_NUM_PARTS_IN_BITS);\n"
	"	// Get only the lower bits where the triangle index is stored\n"
	"	return (rootNode->m_escapeIndexOrTriangleIndex&~(y));\n"
	"}\n"
	"i32 isLeaf(const QuantizedBvhNode* rootNode)\n"
	"{\n"
	"	//skipindex is negative (internal node), triangleindex >=0 (leafnode)\n"
	"	return (rootNode->m_escapeIndexOrTriangleIndex >= 0)? 1 : 0;\n"
	"}\n"
	"	\n"
	"i32 getEscapeIndex(const QuantizedBvhNode* rootNode)\n"
	"{\n"
	"	return -rootNode->m_escapeIndexOrTriangleIndex;\n"
	"}\n"
	"typedef struct\n"
	"{\n"
	"	//12 bytes\n"
	"	u16	m_quantizedAabbMin[3];\n"
	"	u16	m_quantizedAabbMax[3];\n"
	"	//4 bytes, points to the root of the subtree\n"
	"	i32			m_rootNodeIndex;\n"
	"	//4 bytes\n"
	"	i32			m_subtreeSize;\n"
	"	i32			m_padding[3];\n"
	"} BvhSubtreeInfo;\n"
	"///keep this in sync with Collidable.h\n"
	"typedef struct\n"
	"{\n"
	"	i32 m_numChildShapes;\n"
	"	i32 blaat2;\n"
	"	i32 m_shapeType;\n"
	"	i32 m_shapeIndex;\n"
	"	\n"
	"} CollidableGpu;\n"
	"typedef struct\n"
	"{\n"
	"	float4	m_childPosition;\n"
	"	float4	m_childOrientation;\n"
	"	i32 m_shapeIndex;\n"
	"	i32 m_unused0;\n"
	"	i32 m_unused1;\n"
	"	i32 m_unused2;\n"
	"} GpuChildShape;\n"
	"typedef struct\n"
	"{\n"
	"	float4 m_pos;\n"
	"	float4 m_quat;\n"
	"	float4 m_linVel;\n"
	"	float4 m_angVel;\n"
	"	u32 m_collidableIdx;\n"
	"	float m_invMass;\n"
	"	float m_restituitionCoeff;\n"
	"	float m_frictionCoeff;\n"
	"} BodyData;\n"
	"typedef struct \n"
	"{\n"
	"	union\n"
	"	{\n"
	"		float4	m_min;\n"
	"		float   m_minElems[4];\n"
	"		i32			m_minIndices[4];\n"
	"	};\n"
	"	union\n"
	"	{\n"
	"		float4	m_max;\n"
	"		float   m_maxElems[4];\n"
	"		i32			m_maxIndices[4];\n"
	"	};\n"
	"} AabbCL;\n"
	"i32 testQuantizedAabbAgainstQuantizedAabb(\n"
	"								u16k* aabbMin1,\n"
	"								u16k* aabbMax1,\n"
	"								u16k* aabbMin2,\n"
	"								u16k* aabbMax2)\n"
	"{\n"
	"	//i32 overlap = 1;\n"
	"	if (aabbMin1[0] > aabbMax2[0])\n"
	"		return 0;\n"
	"	if (aabbMax1[0] < aabbMin2[0])\n"
	"		return 0;\n"
	"	if (aabbMin1[1] > aabbMax2[1])\n"
	"		return 0;\n"
	"	if (aabbMax1[1] < aabbMin2[1])\n"
	"		return 0;\n"
	"	if (aabbMin1[2] > aabbMax2[2])\n"
	"		return 0;\n"
	"	if (aabbMax1[2] < aabbMin2[2])\n"
	"		return 0;\n"
	"	return 1;\n"
	"	//overlap = ((aabbMin1[0] > aabbMax2[0]) || (aabbMax1[0] < aabbMin2[0])) ? 0 : overlap;\n"
	"	//overlap = ((aabbMin1[2] > aabbMax2[2]) || (aabbMax1[2] < aabbMin2[2])) ? 0 : overlap;\n"
	"	//overlap = ((aabbMin1[1] > aabbMax2[1]) || (aabbMax1[1] < aabbMin2[1])) ? 0 : overlap;\n"
	"	//return overlap;\n"
	"}\n"
	"void quantizeWithClamp(unsigned short* out, float4 point2,i32 isMax, float4 bvhAabbMin, float4 bvhAabbMax, float4 bvhQuantization)\n"
	"{\n"
	"	float4 clampedPoint = max(point2,bvhAabbMin);\n"
	"	clampedPoint = min (clampedPoint, bvhAabbMax);\n"
	"	float4 v = (clampedPoint - bvhAabbMin) * bvhQuantization;\n"
	"	if (isMax)\n"
	"	{\n"
	"		out[0] = (unsigned short) (((unsigned short)(v.x+1.f) | 1));\n"
	"		out[1] = (unsigned short) (((unsigned short)(v.y+1.f) | 1));\n"
	"		out[2] = (unsigned short) (((unsigned short)(v.z+1.f) | 1));\n"
	"	} else\n"
	"	{\n"
	"		out[0] = (unsigned short) (((unsigned short)(v.x) & 0xfffe));\n"
	"		out[1] = (unsigned short) (((unsigned short)(v.y) & 0xfffe));\n"
	"		out[2] = (unsigned short) (((unsigned short)(v.z) & 0xfffe));\n"
	"	}\n"
	"}\n"
	"// work-in-progress\n"
	"__kernel void   bvhTraversalKernel( __global const int4* pairs, \n"
	"									__global const BodyData* rigidBodies, \n"
	"									__global const CollidableGpu* collidables,\n"
	"									__global AabbCL* aabbs,\n"
	"									__global int4* concavePairsOut,\n"
	"									__global  i32* numConcavePairsOut,\n"
	"									__global const BvhSubtreeInfo* subtreeHeadersRoot,\n"
	"									__global const QuantizedBvhNode* quantizedNodesRoot,\n"
	"									__global const b3BvhInfo* bvhInfos,\n"
	"									i32 numPairs,\n"
	"									i32 maxNumConcavePairsCapacity)\n"
	"{\n"
	"	i32 id = get_global_id(0);\n"
	"	if (id>=numPairs)\n"
	"		return;\n"
	"	\n"
	"	i32 bodyIndexA = pairs[id].x;\n"
	"	i32 bodyIndexB = pairs[id].y;\n"
	"	i32 collidableIndexA = rigidBodies[bodyIndexA].m_collidableIdx;\n"
	"	i32 collidableIndexB = rigidBodies[bodyIndexB].m_collidableIdx;\n"
	"	\n"
	"	//once the broadphase avoids static-static pairs, we can remove this test\n"
	"	if ((rigidBodies[bodyIndexA].m_invMass==0) &&(rigidBodies[bodyIndexB].m_invMass==0))\n"
	"	{\n"
	"		return;\n"
	"	}\n"
	"		\n"
	"	if (collidables[collidableIndexA].m_shapeType!=SHAPE_CONCAVE_TRIMESH)\n"
	"		return;\n"
	"	i32 shapeTypeB = collidables[collidableIndexB].m_shapeType;\n"
	"		\n"
	"	if (shapeTypeB!=SHAPE_CONVEX_HULL &&\n"
	"		shapeTypeB!=SHAPE_SPHERE	&&\n"
	"		shapeTypeB!=SHAPE_COMPOUND_OF_CONVEX_HULLS\n"
	"		)\n"
	"		return;\n"
	"	b3BvhInfo bvhInfo = bvhInfos[collidables[collidableIndexA].m_numChildShapes];\n"
	"	float4 bvhAabbMin = bvhInfo.m_aabbMin;\n"
	"	float4 bvhAabbMax = bvhInfo.m_aabbMax;\n"
	"	float4 bvhQuantization = bvhInfo.m_quantization;\n"
	"	i32 numSubtreeHeaders = bvhInfo.m_numSubTrees;\n"
	"	__global const BvhSubtreeInfo* subtreeHeaders = &subtreeHeadersRoot[bvhInfo.m_subTreeOffset];\n"
	"	__global const QuantizedBvhNode* quantizedNodes = &quantizedNodesRoot[bvhInfo.m_nodeOffset];\n"
	"	\n"
	"	u16 quantizedQueryAabbMin[3];\n"
	"	u16 quantizedQueryAabbMax[3];\n"
	"	quantizeWithClamp(quantizedQueryAabbMin,aabbs[bodyIndexB].m_min,false,bvhAabbMin, bvhAabbMax,bvhQuantization);\n"
	"	quantizeWithClamp(quantizedQueryAabbMax,aabbs[bodyIndexB].m_max,true ,bvhAabbMin, bvhAabbMax,bvhQuantization);\n"
	"	\n"
	"	for (i32 i=0;i<numSubtreeHeaders;i++)\n"
	"	{\n"
	"		BvhSubtreeInfo subtree = subtreeHeaders[i];\n"
	"				\n"
	"		i32 overlap = testQuantizedAabbAgainstQuantizedAabb(quantizedQueryAabbMin,quantizedQueryAabbMax,subtree.m_quantizedAabbMin,subtree.m_quantizedAabbMax);\n"
	"		if (overlap != 0)\n"
	"		{\n"
	"			i32 startNodeIndex = subtree.m_rootNodeIndex;\n"
	"			i32 endNodeIndex = subtree.m_rootNodeIndex+subtree.m_subtreeSize;\n"
	"			i32 curIndex = startNodeIndex;\n"
	"			i32 escapeIndex;\n"
	"			i32 isLeafNode;\n"
	"			i32 aabbOverlap;\n"
	"			while (curIndex < endNodeIndex)\n"
	"			{\n"
	"				QuantizedBvhNode rootNode = quantizedNodes[curIndex];\n"
	"				aabbOverlap = testQuantizedAabbAgainstQuantizedAabb(quantizedQueryAabbMin,quantizedQueryAabbMax,rootNode.m_quantizedAabbMin,rootNode.m_quantizedAabbMax);\n"
	"				isLeafNode = isLeaf(&rootNode);\n"
	"				if (aabbOverlap)\n"
	"				{\n"
	"					if (isLeafNode)\n"
	"					{\n"
	"						i32 triangleIndex = getTriangleIndex(&rootNode);\n"
	"						if (shapeTypeB==SHAPE_COMPOUND_OF_CONVEX_HULLS)\n"
	"						{\n"
	"								i32 numChildrenB = collidables[collidableIndexB].m_numChildShapes;\n"
	"								i32 pairIdx = atomic_add(numConcavePairsOut,numChildrenB);\n"
	"								for (i32 b=0;b<numChildrenB;b++)\n"
	"								{\n"
	"									if ((pairIdx+b)<maxNumConcavePairsCapacity)\n"
	"									{\n"
	"										i32 childShapeIndexB = collidables[collidableIndexB].m_shapeIndex+b;\n"
	"										int4 newPair = (int4)(bodyIndexA,bodyIndexB,triangleIndex,childShapeIndexB);\n"
	"										concavePairsOut[pairIdx+b] = newPair;\n"
	"									}\n"
	"								}\n"
	"						} else\n"
	"						{\n"
	"							i32 pairIdx = atomic_inc(numConcavePairsOut);\n"
	"							if (pairIdx<maxNumConcavePairsCapacity)\n"
	"							{\n"
	"								int4 newPair = (int4)(bodyIndexA,bodyIndexB,triangleIndex,0);\n"
	"								concavePairsOut[pairIdx] = newPair;\n"
	"							}\n"
	"						}\n"
	"					} \n"
	"					curIndex++;\n"
	"				} else\n"
	"				{\n"
	"					if (isLeafNode)\n"
	"					{\n"
	"						curIndex++;\n"
	"					} else\n"
	"					{\n"
	"						escapeIndex = getEscapeIndex(&rootNode);\n"
	"						curIndex += escapeIndex;\n"
	"					}\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"}\n";
